<html><head><title>SurviveJS - Webpack and React - From Notes to Kanban</title><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimal-ui"><meta name="description" content="

So far we have managed to set up a nice little development environment. We have developed an application for keeping track of notes in localStorage. We still have work to do to turn this into a real Kanban as pictured above.

Most importantly our system is missing the concept of Lane. A Lane is soâ€¦"><meta name="keywords" content="webpack,react,javascript,programming,web development"><link rel="icon" type="image/png" href="../../assets/img/favicon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><link rel="stylesheet" href="../../assets/main.css"></head><body><div><div class="nav__wrapper"><input type="checkbox" class="nav__toggle" id="nav__toggle"><label class="nav__toggle-label" for="nav__toggle"></label><nav class="nav"><div class="nav__link"><a href="/">Home</a></div><div class="nav__link"><a href="/blog">Read the blog</a></div><div class="nav__link"><a href="https://leanpub.com/survivejs_webpack">Buy the ebook</a></div><div class="nav__link"><a href=""></a></div><div class="nav__link"><a href="https://twitter.com/survivejs">@survivejs</a></div></nav></div><div class="right ribbon github-fork-ribbon-wrapper"><div class="github-fork-ribbon" style="background-color:black;"><a href="https://github.com/survivejs/webpack_react/issues/new?title=From Notes to Kanban - " target="_blank">Submit feedback</a></div></div><main role="main"><div class="chapter__wrapper"><div class="header-image" style="background-image:url(/images/kanban_photo.jpg);"></div><h1 class="post__heading">From Notes to Kanban</h1><div class="toc-nav__wrapper"><h4 class="toc-nav--header">Table of Contents</h4><div class="toc-nav"><a href="/webpack_react/introduction" class="toc-nav__link chapter">Introduction</a><a href="/webpack_react/webpack" class="toc-nav__link part">Setting Up Webpack</a><a href="/webpack_react/webpack_compared" class="toc-nav__link chapter">Webpack Compared</a><a href="/webpack_react/developing_with_webpack" class="toc-nav__link chapter">Developing with Webpack</a><a href="/webpack_react/webpack_and_react" class="toc-nav__link chapter">Webpack and React</a><a href="/webpack_react/react" class="toc-nav__link part">Developing Kanban Application</a><a href="/webpack_react/implementing_notes" class="toc-nav__link chapter">Implementing a Basic Note Application</a><a href="/webpack_react/react_and_flux" class="toc-nav__link chapter">React and Flux</a><span class="toc-nav__link toc-nav__link--current chapter">From Notes to Kanban</span><a href="/webpack_react/implementing_dnd" class="toc-nav__link chapter">Implementing Drag and Drop</a><a href="/webpack_react/building_kanban" class="toc-nav__link chapter">Building Kanban</a><a href="/webpack_react/advanced" class="toc-nav__link part">Advanced Techniques</a><a href="/webpack_react/linting_in_webpack" class="toc-nav__link chapter">Linting in Webpack</a><a href="/webpack_react/authoring_libraries" class="toc-nav__link chapter">Authoring Libraries</a><a href="/webpack_react/styling_react" class="toc-nav__link chapter">Styling React</a><a href="/webpack_react/troubleshooting" class="toc-nav__link chapter">Troubleshooting</a></div></div><div class="chapter"><div class="post__content"><div class="post__meta"><div class="post__start_source"><a href="https://github.com/survivejs/webpack_react/tree/master/project_source/05_react_and_flux/kanban_app" target="_blank">Start source code</a></div><div class="post__end_source"><a href="https://github.com/survivejs/webpack_react/tree/master/project_source/06_from_notes_to_kanban/kanban_app" target="_blank">Finished source code</a></div><div class="post__demo"><a href="/demos/06_from_notes_to_kanban" target="_blank">Demo</a></div></div><div><p><img src="/images/kanban_05.png" alt="Kanban board"></p>
<p>So far we have managed to set up a nice little development environment. We have developed an application for keeping track of notes in <code>localStorage</code>. We still have work to do to turn this into a real Kanban as pictured above.</p>
<p>Most importantly our system is missing the concept of <code>Lane</code>. A <code>Lane</code> is something that should be able to contain many <code>Notes</code> within itself. In the current system that is implicit. We&apos;ll need to extract that into a component of its own.</p>
<a class="header-anchor" href="#extracting-lanes-" id="extracting-lanes-"></a><h2>Extracting <code>Lanes</code><a class="header-anchor-select" href="#extracting-lanes-">#</a></h2>
<p>As earlier, we can use the same idea of two components here. There will be a component for the higher level (i.e. <code>Lanes</code>) and for the lower level (i.e. <code>Lane</code>). The higher level component will deal with lane ordering. A <code>Lane</code> will render itself (i.e. name and <code>Notes</code>) and have basic manipulation operations.</p>
<p>Just as with <code>Notes</code> we are going to need a set of actions. For now it is enough if we can just create new lanes so we can create a corresponding action for that as below:</p>
<p><strong>app/actions/LaneActions.js</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> alt <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../libs/alt&apos;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> alt.generateActions(<span class="hljs-string">&apos;create&apos;</span>);
</code></pre>
<p>In addition, we are going to need a <code>LaneStore</code> and a method matching to <code>create</code>. The idea is pretty much the same as for <code>NoteStore</code> earlier. <code>create</code> will concatenate a new lane to the list of lanes. After that the change will propagate to the listeners (i.e. <code>FinalStore</code> and components).</p>
<p><strong>app/stores/LaneStore.js</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> uuid <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;node-uuid&apos;</span>;
<span class="hljs-keyword">import</span> alt <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../libs/alt&apos;</span>;
<span class="hljs-keyword">import</span> LaneActions <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../actions/LaneActions&apos;</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LaneStore</span> </span>{
  constructor() {
    <span class="hljs-keyword">this</span>.bindActions(LaneActions);

    <span class="hljs-keyword">this</span>.lanes = [];
  }
  create(lane) {
    <span class="hljs-keyword">const</span> lanes = <span class="hljs-keyword">this</span>.lanes;

    lane.id = uuid.v4();
    lane.notes = lane.notes || [];

    <span class="hljs-keyword">this</span>.setState({
      lanes: lanes.concat(lane)
    });
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> alt.createStore(LaneStore, <span class="hljs-string">&apos;LaneStore&apos;</span>);
</code></pre>
<p>We are also going to need a stub for <code>Lanes</code>. We will expand this later. Now we just want something simple to show up.</p>
<p><strong>app/components/Lanes.jsx</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;react&apos;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lanes</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&apos;lanes&apos;</span>&gt;</span>
        lanes should go here
      <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    )</span>;
  }
}
</code></pre>
<p>Next, we need to make room for <code>Lanes</code> at <code>App</code>. We will simply replace <code>Notes</code> references with <code>Lanes</code>, set up actions and store needed:</p>
<p><strong>app/components/App.jsx</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> AltContainer <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;alt/AltContainer&apos;</span>;
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;react&apos;</span>;
<span class="hljs-keyword">import</span> Lanes <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./Lanes.jsx&apos;</span>;
<span class="hljs-keyword">import</span> LaneActions <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../actions/LaneActions&apos;</span>;
<span class="hljs-keyword">import</span> LaneStore <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../stores/LaneStore&apos;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">button</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&apos;add-lane&apos;</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{this.addItem}</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">AltContainer</span>
          <span class="hljs-attribute">stores</span>=<span class="hljs-value">{[LaneStore]}</span>
          <span class="hljs-attribute">inject</span>=<span class="hljs-value">{</span> {
            <span class="hljs-attribute">items:</span> () =&gt;</span> LaneStore.getState().lanes || []
          } }
        &gt;
          <span class="hljs-tag">&lt;<span class="hljs-title">Lanes</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">AltContainer</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    )</span>;
  }
  addItem() {
    LaneActions.create({name: <span class="hljs-string">&apos;New lane&apos;</span>});
  }
}
</code></pre>
<p>The current implementation doesn&apos;t do much. It just shows a plus button and <em>lanes should go here</em> text. Even the add button doesn&apos;t work yet. We still need to model <code>Lane</code> and attach <code>Notes</code> to that to make this all work.</p>
<a class="header-anchor" href="#modeling-lane-" id="modeling-lane-"></a><h2>Modeling <code>Lane</code><a class="header-anchor-select" href="#modeling-lane-">#</a></h2>
<p>The <code>Lanes</code> container will render each <code>Lane</code> separately. Each <code>Lane</code> in turn will then render associated <code>Notes</code> just like our <code>App</code> did earlier. <code>Lanes</code> is analogous to <code>Notes</code> in this manner. The example below illustrates how to set this up:</p>
<p><strong>app/components/Lanes.jsx</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;react&apos;</span>;
<span class="hljs-keyword">import</span> Lane <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./Lane.jsx&apos;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lanes</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">const</span> lanes = <span class="hljs-keyword">this</span>.props.items;

    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&apos;lanes&apos;</span>&gt;</span>{lanes.map(this.renderLane)}<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>;</span>
  }
  renderLane(lane) {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Lane</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&apos;lane&apos;</span> <span class="hljs-attribute">key</span>=<span class="hljs-value">{`lane${lane.id}`}</span> {<span class="hljs-attribute">...lane</span>} /&gt;</span>;</span>
  }
}
</code></pre>
<p>Note that we are using Object rest spread syntax <code>{...lane}</code> to pass lane specific props to each <code>Lane</code>.</p>
<p>We are also going to need a <code>Lane</code> component to make this work. It will render the <code>Lane</code> name and associated <code>Notes</code>. The example below has been modeled largely after our earlier implementation of <code>App</code>. It will render an entire lane including its name and associated notes:</p>
<p><strong>app/components/Lane.jsx</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> AltContainer <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;alt/AltContainer&apos;</span>;
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;react&apos;</span>;
<span class="hljs-keyword">import</span> Notes <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./Notes.jsx&apos;</span>;
<span class="hljs-keyword">import</span> NoteActions <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../actions/NoteActions&apos;</span>;
<span class="hljs-keyword">import</span> NoteStore <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../stores/NoteStore&apos;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lane</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">const</span> {name, ...props} = <span class="hljs-keyword">this</span>.props;

    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> {<span class="hljs-attribute">...props</span>}&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&apos;lane-header&apos;</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&apos;lane-name&apos;</span>&gt;</span>{name}<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&apos;lane-add-note&apos;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">button</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{this.addNote}</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">AltContainer</span>
          <span class="hljs-attribute">stores</span>=<span class="hljs-value">{[NoteStore]}</span>
          <span class="hljs-attribute">inject</span>=<span class="hljs-value">{</span> {
            <span class="hljs-attribute">items:</span> () =&gt;</span> NoteStore.getState().notes || []
          } }
        &gt;
          <span class="hljs-tag">&lt;<span class="hljs-title">Notes</span> <span class="hljs-attribute">onEdit</span>=<span class="hljs-value">{this.editNote}</span> <span class="hljs-attribute">onDelete</span>=<span class="hljs-value">{this.deleteNote}</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">AltContainer</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    )</span>;
  }
  addNote() {
    NoteActions.create({task: <span class="hljs-string">&apos;New task&apos;</span>});
  }
  editNote(id, task) {
    NoteActions.update({id, task});
  }
  deleteNote(id) {
    NoteActions.delete(id);
  }
}
</code></pre>
<p>I am using <a href="https://github.com/sebmarkbage/ecmascript-rest-spread">Object rest spread syntax (stage 1)</a> (<code>{a, b, ...props} = this.props</code>) in the example. This allows us to attach a <code>className</code> to <code>Lane</code> and we avoid polluting it with HTML attributes we don&apos;t need.</p>
<p>If you run the application, you can see there&apos;s something wrong. If you add new <code>Notes</code> to a <code>Lane</code>, the <code>Note</code> appears to each <code>Lane</code>. Also if you modify a <code>Note</code>, also other <code>Lanes</code> update.</p>
<p><img src="/images/kanban_01.png" alt="Duplicate notes"></p>
<p>The reason why this happens is simple. Our <code>NoteStore</code> is a singleton. This means every component that is listening to <code>NoteStore</code> will receive the same data. We will need to resolve this problem.</p>
<a class="header-anchor" href="#making-lanes-responsible-of-notes-" id="making-lanes-responsible-of-notes-"></a><h2>Making <code>Lanes</code> Responsible of <code>Notes</code><a class="header-anchor-select" href="#making-lanes-responsible-of-notes-">#</a></h2>
<p>Currently our <code>Lane</code> model is simple. We are just storing an array of objects. Each of the objects knows its <em>id</em> and <em>name</em>. We&apos;ll need something more. Each <code>Lane</code> needs to know which <code>Notes</code> belong to it. If a <code>Lane</code> contained an array of <code>Note</code> ids, it could then filter and display the <code>Notes</code> belonging to it.</p>
<a class="header-anchor" href="#setting-up-attachtolane-" id="setting-up-attachtolane-"></a><h3>Setting Up <code>attachToLane</code><a class="header-anchor-select" href="#setting-up-attachtolane-">#</a></h3>
<p>When we add a new <code>Note</code> to the system using <code>addNote</code>, we need to make sure it&apos;s associated to some <code>Lane</code>. This association can be modeled using a method such as <code>LaneActions.attachToLane({laneId: &lt;id&gt;})</code>. As a <code>Note</code> needs to exist before this association can be made, this method needs to <code>waitFor</code> it. Here&apos;s an example of how we would use the API:</p>
<pre><code class="undefinedjavascript">NoteActions.create({task: <span class="hljs-string">&apos;New task&apos;</span>});
LaneActions.attachToLane({laneId});
</code></pre>
<p>This is a special feature of Flux that allows us to perform this kind of synchronization. It allows <code>attachToLane</code> to wait until a <code>Note</code> has been created. Before using it, however, you should always consider other ways first. In this case it is an absolute necessity.</p>
<p>To get started we should add <code>attachToLane</code> to actions as before:</p>
<p><strong>app/actions/LaneActions.js</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> alt <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../libs/alt&apos;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> alt.generateActions(<span class="hljs-string">&apos;create&apos;</span>, <span class="hljs-string">&apos;attachToLane&apos;</span>);
</code></pre>
<p>The next step takes more code. We need to take care of attaching:</p>
<p><strong>app/stores/LaneStore.js</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> uuid <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;node-uuid&apos;</span>;
<span class="hljs-keyword">import</span> alt <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../libs/alt&apos;</span>;
<span class="hljs-keyword">import</span> LaneActions <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../actions/LaneActions&apos;</span>;
<span class="hljs-keyword">import</span> NoteStore <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./NoteStore&apos;</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LaneStore</span> </span>{
  ...
  attachToLane({laneId, noteId}) {
    <span class="hljs-keyword">if</span>(!noteId) {
      <span class="hljs-keyword">this</span>.waitFor(NoteStore);

      noteId = NoteStore.getState().notes.slice(-<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>].id;
    }

    <span class="hljs-keyword">const</span> lanes = <span class="hljs-keyword">this</span>.lanes;
    <span class="hljs-keyword">const</span> targetId = <span class="hljs-keyword">this</span>.findLane(laneId);

    <span class="hljs-keyword">if</span>(targetId &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">const</span> lane = lanes[targetId];

    <span class="hljs-keyword">if</span>(lane.notes.indexOf(noteId) === -<span class="hljs-number">1</span>) {
      lane.notes.push(noteId);

      <span class="hljs-keyword">this</span>.setState({lanes});
    }
    <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">&apos;Already attached note to lane&apos;</span>, lanes);
    }
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> alt.createStore(LaneStore, <span class="hljs-string">&apos;LaneStore&apos;</span>);
</code></pre>
<p><code>attachToLane</code> has been coded defensively to guard against possible problems. Unless we pass <code>noteId</code> we <code>waitFor</code> one. Passing one explicitly becomes useful when we implement drag and drop so it&apos;s good to have it in place.</p>
<p>The rest of the code deals with the logic. First we try to find a matching lane. If found, we attach the note id to it unless it has been attached already.</p>
<a class="header-anchor" href="#setting-up-detachfromlane-" id="setting-up-detachfromlane-"></a><h3>Setting Up <code>detachFromLane</code><a class="header-anchor-select" href="#setting-up-detachfromlane-">#</a></h3>
<p><code>deleteNote</code> is the opposite operation of <code>addNote</code>. When removing a <code>Note</code>, it&apos;s important to remember to remove association related to it from a <code>Lane</code> as well. For this purpose we can implement <code>LaneActions.detachFromLane({laneId: &lt;id&gt;})</code>. We would use it like this:</p>
<pre><code class="undefinedjavascript">NoteActions.delete(noteId);
LaneActions.detachFromLane({laneId, noteId});
</code></pre>
<p>Again, we should set up an action:</p>
<p><strong>app/actions/LaneActions.js</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> alt <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../libs/alt&apos;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> alt.generateActions(<span class="hljs-string">&apos;create&apos;</span>, <span class="hljs-string">&apos;attachToLane&apos;</span>, <span class="hljs-string">&apos;detachFromLane&apos;</span>);
</code></pre>
<p>The implementation will resemble <code>attachToLane</code>. In this case we&apos;ll remove the possibly found <code>Note</code> instead:</p>
<p><strong>app/stores/LaneStore.js</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> uuid <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;node-uuid&apos;</span>;
<span class="hljs-keyword">import</span> alt <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../libs/alt&apos;</span>;
<span class="hljs-keyword">import</span> LaneActions <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../actions/LaneActions&apos;</span>;
<span class="hljs-keyword">import</span> NoteStore <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./NoteStore&apos;</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LaneStore</span> </span>{
  attachToLane({laneId, noteId}) {
    ...
  }
  detachFromLane({laneId, noteId}) {
    <span class="hljs-keyword">const</span> lanes = <span class="hljs-keyword">this</span>.lanes;
    <span class="hljs-keyword">const</span> targetId = <span class="hljs-keyword">this</span>.findLane(laneId);

    <span class="hljs-keyword">if</span>(targetId &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">const</span> lane = lanes[targetId];
    <span class="hljs-keyword">const</span> notes = lane.notes;
    <span class="hljs-keyword">const</span> removeIndex = notes.indexOf(noteId);

    <span class="hljs-keyword">if</span>(removeIndex !== -<span class="hljs-number">1</span>) {
      lane.notes = notes.slice(<span class="hljs-number">0</span>, removeIndex).
        concat(notes.slice(removeIndex + <span class="hljs-number">1</span>));

      <span class="hljs-keyword">this</span>.setState({lanes});
    }
    <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">&apos;Failed to remove note from a lane as it didn\&apos;t exist&apos;</span>, lanes);
    }
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> alt.createStore(LaneStore, <span class="hljs-string">&apos;LaneStore&apos;</span>);
</code></pre>
<p>Again, the implementation has been coded drag and drop in mind. Later on we&apos;ll want to pass <code>noteId</code> explicitly so it doesn&apos;t hurt to have it there. You&apos;ve seen the rest of the code earlier in different contexts.</p>
<a class="header-anchor" href="#implementing-findlane-" id="implementing-findlane-"></a><h3>Implementing <code>findLane</code><a class="header-anchor-select" href="#implementing-findlane-">#</a></h3>
<p>Both <code>attachToLane</code> and <code>detachFromLane</code> depend on a helper method known as <code>findLane</code>. As you might guess from the name, it will return a <code>Lane</code> index if found:</p>
<p><strong>app/stores/LaneStore.js</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> uuid <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;node-uuid&apos;</span>;
<span class="hljs-keyword">import</span> alt <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../libs/alt&apos;</span>;
<span class="hljs-keyword">import</span> LaneActions <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../actions/LaneActions&apos;</span>;
<span class="hljs-keyword">import</span> NoteStore <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./NoteStore&apos;</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LaneStore</span> </span>{
  ...
  detachFromLane({laneId, noteId}) {
    ...
  }
  findLane(id) {
    <span class="hljs-keyword">const</span> lanes = <span class="hljs-keyword">this</span>.lanes;
    <span class="hljs-keyword">const</span> laneIndex = lanes.findIndex((lane) =&gt; lane.id === id);

    <span class="hljs-keyword">if</span>(laneIndex &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">&apos;Failed to find lane&apos;</span>, lanes, id);
    }

    <span class="hljs-keyword">return</span> laneIndex;
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> alt.createStore(LaneStore, <span class="hljs-string">&apos;LaneStore&apos;</span>);
</code></pre>
<p><code>findLane</code> has been coded defensively to warn if a <code>Lane</code> is not found. It relies on <code>findIndex</code> discussed earlier.</p>
<a class="header-anchor" href="#implementing-a-getter-for-notestore-" id="implementing-a-getter-for-notestore-"></a><h3>Implementing a Getter for <code>NoteStore</code><a class="header-anchor-select" href="#implementing-a-getter-for-notestore-">#</a></h3>
<p>Given our lanes contain references to notes through ids, we are going to need some way to resolve those ids to actual notes. One neat way to do this is to implement a public method, <code>NoteStore.get(notes)</code> for the purpose. It takes an array of <code>Note</code> ids in and returns corresponding objects.</p>
<p>This can be achieved using the <code>map</code> operation. First we need to get the ids of all notes to match against. After that we can perform a lookup for each note id passed using <code>indexOf</code>.</p>
<p>Just implementing the method isn&apos;t enough. We also need to make it public. In Alt this can be achieved using <code>this.exportPublicMethods</code>. It takes an object that describes the public interface of the store in question. Consider the implementation below:</p>
<p><strong>app/stores/NoteStore.jsx</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> uuid <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;node-uuid&apos;</span>;
<span class="hljs-keyword">import</span> alt <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../libs/alt&apos;</span>;
<span class="hljs-keyword">import</span> NoteActions <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../actions/NoteActions&apos;</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoteStore</span> </span>{
  constructor() {
    <span class="hljs-keyword">this</span>.bindActions(NoteActions);

    <span class="hljs-keyword">this</span>.notes = [];

    <span class="hljs-keyword">this</span>.exportPublicMethods({
      get: <span class="hljs-keyword">this</span>.get.bind(<span class="hljs-keyword">this</span>)
    });
  }
  ...
  get(ids) {
    <span class="hljs-keyword">return</span> (ids || []).map((id) =&gt; <span class="hljs-keyword">this</span>.notes[<span class="hljs-keyword">this</span>.findNote(id)]);
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> alt.createStore(NoteStore, <span class="hljs-string">&apos;NoteStore&apos;</span>);
</code></pre>
<p>Note that the implementation filters possible not matching ids from the result.</p>
<a class="header-anchor" href="#connecting-lane-with-the-logic" id="connecting-lane-with-the-logic"></a><h3>Connecting <code>Lane</code> with the Logic<a class="header-anchor-select" href="#connecting-lane-with-the-logic">#</a></h3>
<p>Now that we have the logical bits together, we can integrate it at <code>Lane</code>. We&apos;ll need to take the newly added props (<code>id</code>, <code>notes</code>) in count and glue this all together:</p>
<p><strong>app/components/Lane.jsx</strong></p>
<pre><code class="undefinedjavascript">...
<span class="hljs-keyword">import</span> LaneActions <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../actions/LaneActions&apos;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lane</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  constructor(props) {
    <span class="hljs-keyword">super</span>(props);

    <span class="hljs-keyword">const</span> id = props.id;

    <span class="hljs-keyword">this</span>.addNote = <span class="hljs-keyword">this</span>.addNote.bind(<span class="hljs-keyword">this</span>, id);
    <span class="hljs-keyword">this</span>.deleteNote = <span class="hljs-keyword">this</span>.deleteNote.bind(<span class="hljs-keyword">this</span>, id);
  }
  render() {
    <span class="hljs-keyword">const</span> {id, name, notes, ...props} = <span class="hljs-keyword">this</span>.props;

    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> {<span class="hljs-attribute">...props</span>}&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&apos;lane-header&apos;</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&apos;lane-name&apos;</span>&gt;</span>{name}<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&apos;lane-add-note&apos;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">button</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{this.addNote}</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">AltContainer</span>
          <span class="hljs-attribute">stores</span>=<span class="hljs-value">{[NoteStore]}</span>
          <span class="hljs-attribute">inject</span>=<span class="hljs-value">{</span> {
            <span class="hljs-attribute">items:</span> () =&gt;</span> NoteStore.get(notes)
          } }
        &gt;
          <span class="hljs-tag">&lt;<span class="hljs-title">Notes</span>
            <span class="hljs-attribute">onEdit</span>=<span class="hljs-value">{this.editNote}</span>
            <span class="hljs-attribute">onDelete</span>=<span class="hljs-value">{this.deleteNote}</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">AltContainer</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    )</span>;
  }
  addNote(laneId) {
    NoteActions.create({task: <span class="hljs-string">&apos;New task&apos;</span>});
    LaneActions.attachToLane({laneId});
  }
  editNote(id, task) {
    NoteActions.update({id, task});
  }
  deleteNote(laneId, noteId) {
    NoteActions.delete(noteId);
    LaneActions.detachFromLane({laneId, noteId});
  }
}
</code></pre>
<p>There are a couple of important changes:</p>
<ul>
<li><code>const {id, name, notes, ...props} = this.props;</code> - New props are taken in count.</li>
<li><code>items: () =&gt; NoteStore.get(notes)</code> - Our new getter is used to filter <code>notes</code>.</li>
<li><code>addNote</code>, <code>deleteNote</code> - These operate now based on the new logic we specified.</li>
</ul>
<p>After these changes we have set up a system that can maintain relations between <code>Lanes</code> and <code>Notes</code>. The current structure allowed us to keep singleton stores and a flat data structure. Dealing with references is a little nasty but that&apos;s consistent with the Flux architecture.</p>
<p><img src="/images/kanban_02.png" alt="Separate notes"></p>
<a class="header-anchor" href="#implementing-edit-remove-for-lane-" id="implementing-edit-remove-for-lane-"></a><h2>Implementing Edit/Remove for <code>Lane</code><a class="header-anchor-select" href="#implementing-edit-remove-for-lane-">#</a></h2>
<p>We are still missing some basic functionality such as editing and removing lanes. We are going to reuse the functionality we used with <code>Note</code> so let&#x2019;s rename it to <code>Editable.jsx</code> and tweak the code a bit to make it generic:</p>
<p><strong>app/components/Editable.jsx</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;react&apos;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Editable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  constructor(props) {
    ...

    <span class="hljs-comment">// this.renderTask = this.renderTask.bind(this);</span>
    <span class="hljs-keyword">this</span>.renderValue = <span class="hljs-keyword">this</span>.renderValue.bind(<span class="hljs-keyword">this</span>);

    <span class="hljs-keyword">this</span>.state = {
      editing: <span class="hljs-literal">false</span>
    };
  }
  render() {
    <span class="hljs-keyword">const</span> {value, onEdit, ...props} = <span class="hljs-keyword">this</span>.props;
    <span class="hljs-keyword">const</span> editing = <span class="hljs-keyword">this</span>.state.editing;

    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> {<span class="hljs-attribute">...props</span>}&gt;</span>
        {editing ? this.renderEdit() : this.renderValue()}
      <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    )</span>;
  }
  renderEdit() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">&apos;text&apos;</span>
      <span class="hljs-attribute">autoFocus</span>=<span class="hljs-value">{true}</span>
      <span class="hljs-attribute">defaultValue</span>=<span class="hljs-value">{this.props.value}</span>
      <span class="hljs-attribute">onBlur</span>=<span class="hljs-value">{this.finishEdit}</span>
      <span class="hljs-attribute">onKeyPress</span>=<span class="hljs-value">{this.checkEnter}</span> /&gt;</span>;</span>
  }
  renderValue() { <span class="hljs-comment">// drop renderTask</span>
    <span class="hljs-keyword">const</span> onDelete = <span class="hljs-keyword">this</span>.props.onDelete;

    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{this.edit}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">span</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&apos;value&apos;</span>&gt;</span>{this.props.value}<span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span>
        {onDelete ? this.renderDelete() : null }
      <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    )</span>;
  }
  ...
}
</code></pre>
<p>There are a couple of important changes:</p>
<ul>
<li><code>this.renderValue = this.renderValue.bind(this);</code> - Previously we had <code>Task</code>, now we are using the term <code>Value</code> as that&apos;s more generic.</li>
<li><code>const {value, onEdit, ...props} = this.props;</code> - We changed task to value here as well.</li>
<li><code>renderValue()</code> - Formerly this was known as <code>renderTask()</code>. Again, an abstraction step. Note that we refer to <code>this.props.value</code> and not <code>this.props.task</code>.</li>
</ul>
<p>Because the class name changes, <code>main.css</code> needs a small tweak:</p>
<p><strong>app/main.css</strong></p>
<pre><code class="undefinedcss"><span class="hljs-comment">/*.note .task {*/</span>
<span class="hljs-class">.note</span> <span class="hljs-class">.value</span> <span class="hljs-rules">{
  <span class="hljs-comment">/* force to use inline-block so that it gets minimum height */</span>
  <span class="hljs-rule"><span class="hljs-attribute">display</span>:<span class="hljs-value"> inline-block</span></span>;
}</span>
</code></pre>
<a class="header-anchor" href="#pointing-notes-to-editable-" id="pointing-notes-to-editable-"></a><h3>Pointing <code>Notes</code> to <code>Editable</code><a class="header-anchor-select" href="#pointing-notes-to-editable-">#</a></h3>
<p>Next, we need to make <code>Notes.jsx</code> point at the new component. We&apos;ll need to alter the import and the component name at <code>render()</code>:</p>
<p><strong>app/components/Notes.jsx</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;react&apos;</span>;
<span class="hljs-keyword">import</span> Editable <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./Editable.jsx&apos;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Notes</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  ...
  renderNote(note) {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&apos;note&apos;</span> <span class="hljs-attribute">key</span>=<span class="hljs-value">{`note${note.id}`}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">Editable</span>
          <span class="hljs-attribute">value</span>=<span class="hljs-value">{note.task}</span>
          <span class="hljs-attribute">onEdit</span>=<span class="hljs-value">{this.props.onEdit.bind(null,</span> <span class="hljs-attribute">note.id</span>)}
          <span class="hljs-attribute">onDelete</span>=<span class="hljs-value">{this.props.onDelete.bind(null,</span> <span class="hljs-attribute">note.id</span>)} /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
    )</span>;
  }
}
</code></pre>
<a class="header-anchor" href="#connecting-lane-with-editable-" id="connecting-lane-with-editable-"></a><h3>Connecting <code>Lane</code> with <code>Editable</code><a class="header-anchor-select" href="#connecting-lane-with-editable-">#</a></h3>
<p>Next, we can use this generic component to allow <code>Lane</code> name to be modified. This will give a hook for our logic. We&apos;ll need to alter <code>&lt;div className=&apos;lane-name&apos;&gt;{name}&lt;/div&gt;</code> as follows:</p>
<p><strong>app/components/Lane.jsx</strong></p>
<pre><code class="undefinedjavascript">...
<span class="hljs-keyword">import</span> Editable <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./Editable.jsx&apos;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lane</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  constructor(props) {
    ...
    <span class="hljs-keyword">this</span>.editName = <span class="hljs-keyword">this</span>.editName.bind(<span class="hljs-keyword">this</span>, id);
  }
  render() {
    <span class="hljs-keyword">const</span> {id, name, notes, ...props} = <span class="hljs-keyword">this</span>.props;

    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> {<span class="hljs-attribute">...props</span>}&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&apos;lane-header&apos;</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-title">Editable</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&apos;lane-name&apos;</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">{name}</span>
            <span class="hljs-attribute">onEdit</span>=<span class="hljs-value">{this.editName}</span> /&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&apos;lane-add-note&apos;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">button</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{this.addNote}</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        ...
      <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    )</span>
  }
  ...
  editName(id, name) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;edited lane name&apos;</span>, id, name);
  }
}
</code></pre>
<p>If you try to edit a lane name now, you should see a print at the console.</p>
<p><img src="/images/kanban_03.png" alt="Logging lane name editing"></p>
<a class="header-anchor" href="#defining-editable-logic" id="defining-editable-logic"></a><h3>Defining <code>Editable</code> Logic<a class="header-anchor-select" href="#defining-editable-logic">#</a></h3>
<p>We will need to define some logic to make this work. To follow the same idea as with <code>Note</code>, we can model the remaining CRUD actions here. We&apos;ll need to set up <code>update</code> and <code>delete</code> actions in particular.</p>
<p><strong>app/actions/LaneActions.js</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> alt <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../libs/alt&apos;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> alt.generateActions(
  <span class="hljs-string">&apos;create&apos;</span>, <span class="hljs-string">&apos;update&apos;</span>, <span class="hljs-string">&apos;delete&apos;</span>,
  <span class="hljs-string">&apos;attachToLane&apos;</span>, <span class="hljs-string">&apos;detachFromLane&apos;</span>
);
</code></pre>
<p>We are also going to need <code>LaneStore</code> level implementations for these. They can be modeled based what we have seen on <code>NoteStore</code> earlier:</p>
<p><strong>app/stores/LaneStore.js</strong></p>
<pre><code class="undefinedjavascript">...

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LaneStore</span> </span>{
  ...
  update({id, name}) {
    <span class="hljs-keyword">const</span> lanes = <span class="hljs-keyword">this</span>.lanes;
    <span class="hljs-keyword">const</span> targetId = <span class="hljs-keyword">this</span>.findLane(id);

    <span class="hljs-keyword">if</span>(targetId &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span>;
    }

    lanes[targetId].name = name;

    <span class="hljs-keyword">this</span>.setState({lanes});
  }
  <span class="hljs-keyword">delete</span>(id) {
    <span class="hljs-keyword">const</span> lanes = <span class="hljs-keyword">this</span>.lanes;
    <span class="hljs-keyword">const</span> targetId = <span class="hljs-keyword">this</span>.findLane(id);

    <span class="hljs-keyword">if</span>(targetId &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">this</span>.setState({
      lanes: lanes.slice(<span class="hljs-number">0</span>, targetId).concat(lanes.slice(targetId + <span class="hljs-number">1</span>))
    });
  }
  attachToLane({laneId}) {
    ...
  }
  ...
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> alt.createStore(LaneStore, <span class="hljs-string">&apos;LaneStore&apos;</span>);
</code></pre>
<p>Now that we have resolved actions and store, we need to adjust our component to take these changes into account:</p>
<p><strong>app/components/Lane.jsx</strong></p>
<pre><code class="undefinedjavascript">...
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lane</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  ...
  editName(id, name) {
    <span class="hljs-keyword">if</span>(name) {
      LaneActions.update({id, name});
    }
    <span class="hljs-keyword">else</span> {
      LaneActions.delete(id);
    }
  }
}
</code></pre>
<p>Try modifying a lane name now. Modifications should get saved now the same way as they do for notes. Deleting lanes should be possible as well.</p>
<p><img src="/images/kanban_04.png" alt="Editing a lane name"></p>
<a class="header-anchor" href="#styling-kanban-board" id="styling-kanban-board"></a><h2>Styling Kanban Board<a class="header-anchor-select" href="#styling-kanban-board">#</a></h2>
<p>As we added <code>Lanes</code> to the application the styling went a bit off. Add the following styling to make it a little nicer:</p>
<p><strong>app/main.css</strong></p>
<pre><code class="undefinedcss"><span class="hljs-tag">body</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">background</span>:<span class="hljs-value"> cornsilk</span></span>;

  <span class="hljs-rule"><span class="hljs-attribute">font-family</span>:<span class="hljs-value"> sans-serif</span></span>;
}</span>

<span class="hljs-class">.lane</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">display</span>:<span class="hljs-value"> inline-block</span></span>;

  <span class="hljs-rule"><span class="hljs-attribute">margin</span>:<span class="hljs-value"> <span class="hljs-number">1em</span></span></span>;

  <span class="hljs-rule"><span class="hljs-attribute">background-color</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#efefef</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">border</span>:<span class="hljs-value"> <span class="hljs-number">1px</span> solid <span class="hljs-hexcolor">#ccc</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">border-radius</span>:<span class="hljs-value"> <span class="hljs-number">0.5em</span></span></span>;

  <span class="hljs-rule"><span class="hljs-attribute">min-width</span>:<span class="hljs-value"> <span class="hljs-number">10em</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">vertical-align</span>:<span class="hljs-value"> top</span></span>;
}</span>

<span class="hljs-class">.lane-header</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">overflow</span>:<span class="hljs-value"> auto</span></span>;

  <span class="hljs-rule"><span class="hljs-attribute">padding</span>:<span class="hljs-value"> <span class="hljs-number">1em</span></span></span>;

  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#efefef</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">background-color</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#333</span></span></span>;

  <span class="hljs-rule"><span class="hljs-attribute">border-top-left-radius</span>:<span class="hljs-value"> <span class="hljs-number">0.5em</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">border-top-right-radius</span>:<span class="hljs-value"> <span class="hljs-number">0.5em</span></span></span>;
}</span>

<span class="hljs-class">.lane-name</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">float</span>:<span class="hljs-value"> left</span></span>;
}</span>

<span class="hljs-class">.lane-add-note</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">float</span>:<span class="hljs-value"> right</span></span>;

  <span class="hljs-rule"><span class="hljs-attribute">margin-left</span>:<span class="hljs-value"> <span class="hljs-number">0.5em</span></span></span>;
}</span>

<span class="hljs-class">.add-lane</span>, <span class="hljs-class">.lane-add-note</span> <span class="hljs-tag">button</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">background-color</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#fdfdfd</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">border</span>:<span class="hljs-value"> <span class="hljs-number">1px</span> solid <span class="hljs-hexcolor">#ccc</span></span></span>;
}</span>

...
</code></pre>
<p>You should end up with a result like this:</p>
<p><img src="/images/kanban_05.png" alt="Styled Kanban"></p>
<p>As this is a small project we can leave the CSS in a single file like this. In case it starts growing, consider separating it to multiple. One way to do this is to extract CSS per component and then refer to it there (e.g., <code>require(&apos;./lane.css&apos;)</code> at <code>Lane.jsx</code>).</p>
<p>Besides keeping things nice and tidy, Webpack&apos;s lazy loading machinery can pick this up. As a result, the initial CSS your user has to load will be smaller. I go into further detail later as I discuss styling.</p>
<a class="header-anchor" href="#on-namespacing-components" id="on-namespacing-components"></a><h2>On Namespacing Components<a class="header-anchor-select" href="#on-namespacing-components">#</a></h2>
<p>So far we&apos;ve been defining a component per file. That&apos;s not the only way. It may be handy to treat a file as a namespace and expose multiple components from it. React provides <a href="https://facebook.github.io/react/docs/jsx-in-depth.html#namespaced-components">namespaces components</a> just for this purpose. In this case we could apply namespacing to the concept of <code>Lane</code> or <code>Note</code>. This would add some additional flexibility to our system while keeping it simple to manage. By using namespacing we could do something like this:</p>
<p><strong>app/components/Lanes.jsx</strong></p>
<pre><code class="undefinedjavascript">...

export default class Lanes extends React.Component {
  render() {
    const lanes = this.props.items;

    return <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&apos;lanes&apos;</span>&gt;</span>{lanes.map(this.renderLane)}<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>;
  }
  renderLane(lane) {
    // new
    return (
      <span class="hljs-tag">&lt;<span class="hljs-title">Lane</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&apos;lane&apos;</span> <span class="hljs-attribute">key</span>=<span class="hljs-value">{`lane${lane.id}`}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">Lane.Header</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">{lane.id}</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">{lane.name}</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">Lane.Notes</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">{lane.id}</span> <span class="hljs-attribute">notes</span>=<span class="hljs-value">{lane.notes}</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">Lane</span>&gt;</span>
    );

    // old
    // return <span class="hljs-tag">&lt;<span class="hljs-title">Lane</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&apos;lane&apos;</span> <span class="hljs-attribute">key</span>=<span class="hljs-value">{`lane${lane.id}`}</span> {<span class="hljs-attribute">...lane</span>} /&gt;</span>;
  }
}
</code></pre>
<p><strong>app/components/Lane.jsx</strong></p>
<pre><code class="undefinedjavascript">...

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lane</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  ...
}

Lane.Header = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LaneHeader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  ...
}
Lane.Notes = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LaneNotes</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  ...
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Lane;
</code></pre>
<p>Now we have pushed the control over <code>Lane</code> formatting to a higher level. In this case the change isn&apos;t worth it but it can make sense in a more complex case.</p>
<p>You can use similar approach for more generic components as well. Consider something like <code>Form</code>. You could easily have <code>Form.Label</code>, <code>Form.Input</code>, <code>Form.Textarea</code> and so on. Each would contain your custom formatting and logic as needed.</p>
<a class="header-anchor" href="#conclusion" id="conclusion"></a><h2>Conclusion<a class="header-anchor-select" href="#conclusion">#</a></h2>
<p>The current design has been optimized drag and drop operations in mind. Moving notes within a lane is a matter of swapping ids. Moving notes from a lane to a lane is again an operation over ids. This structure leads to some complexity as we need to track ids but it will pay off in the next chapter.</p>
<p>There isn&apos;t always a clear cut way to model data and relations. In some other case we could push the references elsewhere. For instance the note to lane relation could be inversed and pushed to <code>Note</code> level. We would still need to track their order within a lane somehow, however. We would be pushing the complexity elsewhere by doing this.</p>
<p>Currently <code>NoteStore</code> is treated as a singleton. Another way to deal within it would be to create <code>NoteStore</code> per <code>Notes</code> dynamically. Even though this simplifies dealing with the relations somewhat, this is a Flux anti-pattern better avoided.</p>
<p>We still cannot move notes between lanes or within a lane. We will solve that in the next chapter as we implement drag and drop.</p>
</div><div class="social-links"><blockquote class="tip">If you enjoyed this chapter consider subscribing to <a href="http://eepurl.com/bth1v5">the mailing list</a> or following <a href="https://twitter.com/survivejs">@survivejs</a> for occasional updates. There is also <a href="/atom.xml">RSS</a> available for old beards (no pun intended).</blockquote></div><div id="disqus_thread"></div></div><div class="prevnext"><div class="prevnext__prev"><div class="prevnext__bg" style="background-image:url(/images/delorean.jpg);"></div><span class="prevnext__info">Previous chapter</span><a class="prevnext__link" href="/webpack_react/react_and_flux">React and Flux</a></div><div class="prevnext__next"><div class="prevnext__bg" style="background-image:url(/images/dnd.jpg);"></div><span class="prevnext__info">Next chapter</span><a class="prevnext__link" href="/webpack_react/implementing_dnd">Implementing Drag and Drop</a></div></div><a class="next-page" href="/webpack_react/implementing_dnd">Implementing Drag and Drop</a><a class="previous-page" href="/webpack_react/react_and_flux">React and Flux</a><div class="header-extra"><a href="https://www.flickr.com/photos/61745819@N00/10588140955">Radek Orszewski (CC BY-NC-ND)</a></div></div><script type="text/javascript">var disqus_shortname = 'survivejs';(function() {var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script></div><noscript></noscript></main></div></body></html>