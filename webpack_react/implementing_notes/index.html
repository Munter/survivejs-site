<html><head><title>SurviveJS - Webpack and React - Implementing a Basic Note Application</title><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimal-ui"><link rel="icon" type="image/png" href="../../assets/img/favicon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><link rel="stylesheet" href="../../assets/main.css"></head><body><div><div class="nav__wrapper"><input type="checkbox" class="nav__toggle" id="nav__toggle"><label class="nav__toggle-label" for="nav__toggle"></label><nav class="nav"><div class="nav__link"><a href="/">Home</a></div><div class="nav__link"><a href="/blog">Read the blog</a></div><div class="nav__link"><a href="https://leanpub.com/survivejs_webpack">Buy the ebook</a></div><div class="nav__link"><a href=""></a></div><div class="nav__link"><a href="https://twitter.com/survivejs">@survivejs</a></div></nav></div><div class="right ribbon github-fork-ribbon-wrapper"><div class="github-fork-ribbon" style="background-color:black;"><a href="https://github.com/survivejs/webpack_react/issues/new?title=Implementing a Basic Note Application - " target="_blank">Submit feedback</a></div></div><main role="main"><div class="post"><div class="docs-nav__wrapper docs-nav__wrapper--push-down"><h4 class="docs-nav--header">Table of Contents</h4><div class="docs-nav"><a href="/webpack_react/introduction" class="docs-nav__link">Introduction</a><a href="/webpack_react/webpack_compared" class="docs-nav__link">Webpack Compared</a><a href="/webpack_react/developing_with_webpack" class="docs-nav__link">Developing with webpack</a><a href="/webpack_react/webpack_and_react" class="docs-nav__link">Webpack and React</a><span class="docs-nav__link docs-nav__link--current">Implementing a Basic Note Application</span><a href="/webpack_react/react_and_flux" class="docs-nav__link">React and Flux</a><a href="/webpack_react/from_notes_to_kanban" class="docs-nav__link">From Notes to Kanban</a><a href="/webpack_react/implementing_dnd" class="docs-nav__link">Implementing Drag and Drop</a><a href="/webpack_react/building_kanban" class="docs-nav__link">Building Kanban</a><a href="/webpack_react/linting_in_webpack" class="docs-nav__link">Linting in webpack</a><a href="/webpack_react/deploying_applications" class="docs-nav__link">Deploying Applications</a><a href="/webpack_react/authoring_libraries" class="docs-nav__link">Authoring Libraries</a><a href="/webpack_react/styling_react" class="docs-nav__link">Styling React</a><a href="/webpack_react/troubleshooting" class="docs-nav__link">Troubleshooting</a></div></div><div class="header-image" style="background-image:url(/images/notes.jpg);"></div><h1 class="post__heading">Implementing a Basic Note Application</h1><div class="post__content"><div class="post__meta"><div class="post__start_source"><a href="https://github.com/survivejs/webpack_react/tree/master/project_source/03_webpack_and_react/kanban_app" target="_blank">Start source code</a></div><div class="post__end_source"><a href="https://github.com/survivejs/webpack_react/tree/master/project_source/04_implementing_notes/kanban_app" target="_blank">Finished source code</a></div><div class="post__demo"><a href="/demos/04_implementing_notes" target="_blank">Demo</a></div></div><div><p>Given we have a nice development setup now, we can actually get some work done. Our goal here is to end up with a crude note taking application with basic manipulation operations. We will start by doing things the hard way. We will grow our application from scratch and get into some trouble. After that you should understand better why architecture models such as Flux are needed.</p>
<a class="header-anchor" href="#initial-data-model" id="initial-data-model"></a><h2>Initial Data Model<a class="header-anchor-select" href="#initial-data-model">#</a></h2>
<p>Often a good way to begin designing application is to start with the data. We could model a list of notes as follows:</p>
<pre><code class="undefinedjavascript">[
  {
    id: <span class="hljs-string">&apos;4a068c42-75b2-4ae2-bd0d-284b4abbb8f0&apos;</span>,
    task: <span class="hljs-string">&apos;Learn webpack&apos;</span>
  },
  {
    id: <span class="hljs-string">&apos;4e81fc6e-bfb6-419b-93e5-0242fb6f3f6a&apos;</span>,
    task: <span class="hljs-string">&apos;Learn React&apos;</span>
  },
  {
    id: <span class="hljs-string">&apos;11bbffc8-5891-4b45-b9ea-5c99aadf870f&apos;</span>,
    task: <span class="hljs-string">&apos;Do laundry&apos;</span>
  }
];
</code></pre>
<p>Each note is an object which will contain the data we need including <code>id</code> and <code>task</code> we want to perform. Later on it is possible to extend this data definition to include things like note color or owner.</p>
<a class="header-anchor" href="#on-ids" id="on-ids"></a><h2>On Ids<a class="header-anchor-select" href="#on-ids">#</a></h2>
<p>You probably noticed those ids at the definition above. Ids will become valuable as we grow the project. A naive way to deal with them is to rely on array indexing. That becomes troublesome quite soon, though. For instance if you are referring to data based on array indices and the data changes, each reference has to change too. That is somewhat undesirable.</p>
<p>Instead it can be valuable to use a proper indexing scheme here. Normally this is solved by a backend. As we don&apos;t have one yet, we&apos;ll need to improvise something. A standard known as <a href="https://www.ietf.org/rfc/rfc4122.txt">RFC4122</a> describes a good way to do this. We&apos;ll be using Node.js implementation of it.</p>
<p>Invoke</p>
<blockquote>
<p>npm i node-uuid --save</p>
</blockquote>
<p>at the project root to get it installed. If you open up Node.js cli (<code>node</code>) and try the following, you can see what kind of ids it outputs.</p>
<pre><code class="undefinedjavascript">&gt; uuid = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;node-uuid&apos;</span>)
{ [<span class="hljs-built_in">Function</span>: v4]
  v1: [<span class="hljs-built_in">Function</span>: v1],
  v4: [Circular],
  parse: [<span class="hljs-built_in">Function</span>: parse],
  unparse: [<span class="hljs-built_in">Function</span>: unparse],
  BufferClass: [<span class="hljs-built_in">Function</span>: <span class="hljs-built_in">Array</span>] }
&gt; uuid.v4()
<span class="hljs-string">&apos;1c8e7a12-0b4c-4f23-938c-00d7161f94fc&apos;</span>
</code></pre>
<p><code>uuid.v4()</code> will help us to generate the ids we need for the purposes of this project.</p>
<blockquote class="tip">If you are interested in the math behind this, check out <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier#Random_UUID_probability_of_duplicates">the calculations at Wikipedia</a> for details. You&apos;ll see that the possibility for collisions is somewhat miniscule.</blockquote><a class="header-anchor" href="#connecting-data-with-app-" id="connecting-data-with-app-"></a><h2>Connecting Data with <code>App</code><a class="header-anchor-select" href="#connecting-data-with-app-">#</a></h2>
<p>The next step is connecting this data model with our <code>App</code>. As it will be quite a bit of code I&apos;ve included whole solution below. We&apos;ll improve the solution later on. The current solution is the simplest way to render a list of notes.</p>
<p>We will use a special feature of JSX in form of <code>{}</code>. Within these braces we can mix JavaScript with JSX. In this case we will render a bunch of <code>li</code> elements. Each contains a <code>Note</code>.</p>
<p>In order to tell React in which order to render the elements, we&apos;ll set <code>key</code> property for each. It is important that this is unique or otherwise it won&apos;t be able to figure out the correct order in which to render and it will give a warning about this.</p>
<p><strong>app/components/App.jsx</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> uuid <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;node-uuid&apos;</span>;
...

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">const</span> notes = [
      {
        id: uuid.v4(),
        task: <span class="hljs-string">&apos;Learn webpack&apos;</span>
      },
      {
        id: uuid.v4(),
        task: <span class="hljs-string">&apos;Learn React&apos;</span>
      },
      {
        id: uuid.v4(),
        task: <span class="hljs-string">&apos;Do laundry&apos;</span>
      }
    ];

    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">ul</span>&gt;</span>{notes.map(this.renderNote)}<span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    )</span>;
  }
  renderNote(note) {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">key</span>=<span class="hljs-value">{`note${note.id}`}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">Note</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">{note.task}</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
    )</span>;
  }
}
</code></pre>
<p>If you run the application now, you can see it almost works. There&apos;s only one problem. Each <code>Note</code> shows the same text. Fortunately this is easy to fix.</p>
<blockquote class="tip">If you want to attach comments to your JSX, just use <code>{/* no comments */}</code>.</blockquote><blockquote class="tip">Setting keys let&apos;s React understand where each element belongs when it&apos;s performing diffing over virtual DOM. It&apos;s a good idea to derive it based on a unique id as above. See <a href="https://facebook.github.io/react/docs/multiple-components.html">Multiple Components</a> at React documentation for more information.</blockquote><a class="header-anchor" href="#fixing-note" id="fixing-note"></a><h2>Fixing Note<a class="header-anchor-select" href="#fixing-note">#</a></h2>
<p>The problem is that we haven&apos;t taken <code>value</code> prop in count at <code>Note</code>. In React terms props are something that&apos;s passed to a component from outside. A component that takes only props and doesn&apos;t have any state, is known as a pure component. Pure components in particular are easy to test and work with. In the code below I extract the value of prop and render it.</p>
<p><strong>app/components/Note.jsx</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;react&apos;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Note</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>{this.props.value}<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>;</span>
  }
}
</code></pre>
<p>If you check out the application now, you should see we&apos;re seeing results that are more like it. This is only start, though. Our <code>App</code> is getting cramped. It feels like there&apos;s a component waiting to be extracted.</p>
<a class="header-anchor" href="#extracting-notes" id="extracting-notes"></a><h2>Extracting Notes<a class="header-anchor-select" href="#extracting-notes">#</a></h2>
<p>If we keep on growing <code>App</code> like this we&apos;ll end up in trouble soon. When working with React it is important for you to learn to recognize possible components. We can extract <code>Notes</code> component from <code>App</code>. It will deal with rendering <code>Notes</code> and simplify our <code>App</code> somewhat.</p>
<p>As a first step we should extract the logic from <code>App</code>. It will accept <code>items</code> as a prop and render each just like our <code>App</code> did earlier. I attached some classes there so it&apos;s easier to style the component later.</p>
<p><strong>app/components/Notes.jsx</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;react&apos;</span>;
<span class="hljs-keyword">import</span> Note <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./Note&apos;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Notes</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">const</span> notes = <span class="hljs-keyword">this</span>.props.items;

    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">ul</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&apos;notes&apos;</span>&gt;</span>{notes.map(this.renderNote)}<span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>;</span>
  }
  renderNote(note) {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&apos;note&apos;</span> <span class="hljs-attribute">key</span>=<span class="hljs-value">{`note${note.id}`}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">Note</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">{note.task}</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
    )</span>;
  }
}
</code></pre>
<p>Next we need to hook up <code>App</code> to render through <code>Notes</code>.</p>
<p><strong>app/components/App.jsx</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> uuid <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;node-uuid&apos;</span>;
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;react&apos;</span>;
<span class="hljs-keyword">import</span> Notes <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./Notes&apos;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">const</span> notes = [
      ...
    ];

    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">Notes</span> <span class="hljs-attribute">items</span>=<span class="hljs-value">{notes}</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    )</span>;
  }
}
</code></pre>
<p>Not only this change keeps <code>App</code> cleaner but it also gives us flexibility. If you wanted to have multiple <code>Notes</code> lists, it would be simple now.</p>
<a class="header-anchor" href="#adding-new-items-to-notes-list" id="adding-new-items-to-notes-list"></a><h2>Adding New Items to Notes list<a class="header-anchor-select" href="#adding-new-items-to-notes-list">#</a></h2>
<p>It would be useful if we could add new items to our Notes list. Let&apos;s just do a plus button that adds a new dummy item to our list.</p>
<p>To implement the button, change <code>render</code> method like this:</p>
<p><strong>app/components/App.jsx</strong></p>
<pre><code class="undefinedjavascript">...

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    ...

    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">button</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{this.addItem}</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">Notes</span> <span class="hljs-attribute">items</span>=<span class="hljs-value">{notes}</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    )</span>;
  }
  addItem() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;add item&apos;</span>);
  }
}
</code></pre>
<p>Now when you click the button, you should see something at your browser console.</p>
<a class="header-anchor" href="#connecting-additem-with-data-model" id="connecting-additem-with-data-model"></a><h2>Connecting <code>addItem</code> with Data Model<a class="header-anchor-select" href="#connecting-additem-with-data-model">#</a></h2>
<p>Next we will need to connect this with our data model somehow. It is problematic that data is stored within our <code>render</code> method. React provides a concept known as state for this purpose. We can move our data there like this:</p>
<p><strong>app/components/App.jsx</strong></p>
<pre><code class="undefinedjavascript">...

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  constructor(props) {
    <span class="hljs-keyword">super</span>(props);

    <span class="hljs-keyword">this</span>.state = {
      notes: [
        {
          id: uuid.v4(),
          task: <span class="hljs-string">&apos;Learn webpack&apos;</span>
        },
        {
          id: uuid.v4(),
          task: <span class="hljs-string">&apos;Learn React&apos;</span>
        },
        {
          id: uuid.v4(),
          task: <span class="hljs-string">&apos;Do laundry&apos;</span>
        }
      ]
    };
  }
  render() {
    <span class="hljs-keyword">const</span> notes = <span class="hljs-keyword">this</span>.state.notes;

    ...
  }
}
</code></pre>
<p>Now our <code>render</code> method points at <code>state</code>. As a result we can implement <code>addItem</code> that actually does something useful:</p>
<p><strong>app/components/App.jsx</strong></p>
<pre><code class="undefinedjavascript">...

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  constructor(props) {
    <span class="hljs-keyword">super</span>(props);

    ...

    <span class="hljs-keyword">this</span>.addItem = <span class="hljs-keyword">this</span>.addItem.bind(<span class="hljs-keyword">this</span>);
  }
  ...
  addItem() {
    <span class="hljs-keyword">this</span>.setState({
      notes: <span class="hljs-keyword">this</span>.state.notes.concat([{
        id: uuid.v4(),
        task: <span class="hljs-string">&apos;New task&apos;</span>
      }])
    });
  }
}
</code></pre>
<p>If you hit the button now, you should see new items. It might not be pretty yet but it works.</p>
<a class="header-anchor" href="#how-does-bind-work-" id="how-does-bind-work-"></a><h3>How Does <code>bind</code> Work?<a class="header-anchor-select" href="#how-does-bind-work-">#</a></h3>
<p>We are using <code>bind</code> with <code>addItem</code> because we want to apply the right context to it. It will be <code>undefined</code> by default. As a result <code>this.setState</code> would fail. Through <code>this.addItem.bind(this)</code> we make sure it is bound to the current instance.</p>
<p><code>bind</code> is useful beyond this usage. You can consider it the equivalent of inheritance but for functions. To give you a trivial example see below:</p>
<pre><code class="undefinedjavascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-keyword">const</span> addTwo = add.bind(<span class="hljs-literal">null</span>, <span class="hljs-number">2</span>);

<span class="hljs-built_in">console</span>.log(addTwo(<span class="hljs-number">6</span>)); <span class="hljs-comment">// 8</span>
</code></pre>
<p>We are using <code>bind</code> at <code>constructor</code> to get a small performance benefit. If we applied it on <code>render</code>, it would have to be applied per <code>render</code>. I&apos;ll be using this convention unless it would additional effort through lifecycle hooks. In the future <a href="https://facebook.github.io/react/blog/2015/01/27/react-v0.13.0-beta-1.html#es7-property-initializers">property initializers</a> may solve this issue with neat syntax.</p>
<a class="header-anchor" href="#editing-notes" id="editing-notes"></a><h2>Editing Notes<a class="header-anchor-select" href="#editing-notes">#</a></h2>
<p>Our Notes list is almost useful now. It is a little unfortunate that even though we can add new items to the list, we cannot modify them. It is time to implement edit.</p>
<p>A natural way to do this would be to allow the user to click an item. When an item is clicked, it would be replaced with an input control that would allow you to edit. After confirmed, the modification should remain there.</p>
<p>This means we&apos;ll need to extend <code>Note</code> somehow and communicate possible changes to <code>App</code> so that it knows to update the data model. In addition <code>Note</code> needs to keep track of its edit state and show the correct element (div or input) based on that.</p>
<p>We can achieve these goals using a callback and a ternary expression. Here&apos;s a sample implementation of the idea:</p>
<p><strong>app/components/Note.jsx</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;react&apos;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Note</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  constructor(props) {
    <span class="hljs-keyword">super</span>(props);

    <span class="hljs-keyword">this</span>.finishEdit = <span class="hljs-keyword">this</span>.finishEdit.bind(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.checkEnter = <span class="hljs-keyword">this</span>.checkEnter.bind(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.edit = <span class="hljs-keyword">this</span>.edit.bind(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.renderEdit = <span class="hljs-keyword">this</span>.renderEdit.bind(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.renderValue = <span class="hljs-keyword">this</span>.renderValue.bind(<span class="hljs-keyword">this</span>);

    <span class="hljs-keyword">this</span>.state = {
      edited: <span class="hljs-literal">false</span>
    };
  }
  render() {
    <span class="hljs-keyword">const</span> {value, onEdit, ...props} = <span class="hljs-keyword">this</span>.props;
    <span class="hljs-keyword">const</span> edited = <span class="hljs-keyword">this</span>.state.edited;

    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> {<span class="hljs-attribute">...props</span>}&gt;</span>
      {edited ? this.renderEdit() : this.renderValue()}
    <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>;</span>
  }
  renderEdit() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">&apos;text&apos;</span>
      <span class="hljs-attribute">defaultValue</span>=<span class="hljs-value">{this.props.value}</span>
      <span class="hljs-attribute">onBlur</span>=<span class="hljs-value">{this.finishEdit}</span>
      <span class="hljs-attribute">onKeyPress</span>=<span class="hljs-value">{this.checkEnter}</span>/&gt;</span>;</span>
  }
  renderValue() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{this.edit}</span>&gt;</span>{this.props.value}<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>;</span>
  }
  edit() {
    <span class="hljs-keyword">this</span>.setState({
      edited: <span class="hljs-literal">true</span>
    });
  }
  checkEnter(e) {
    <span class="hljs-keyword">if</span>(e.key === <span class="hljs-string">&apos;Enter&apos;</span>) {
      <span class="hljs-keyword">this</span>.finishEdit(e);
    }
  }
  finishEdit(e) {
    <span class="hljs-keyword">this</span>.props.onEdit(e.target.value);

    <span class="hljs-keyword">this</span>.setState({
      edited: <span class="hljs-literal">false</span>
    });
  }
}
</code></pre>
<p>If you try to edit a <code>Note</code> now, you will see an error (<code>this.props.onEdit is not a function</code>) at console. We&apos;ll fix this shortly.</p>
<p><code>Note</code> keeps track of <em>edited</em> state. We will manipulate that to change the way it is rendered. If we hit <strong>edit</strong>, we&apos;ll trigger edit mode. Once input receives either <em>blur</em> event or Enter key, we&apos;ll finish editing and reset the value. When finishing we also trigger a callback so the app knows to react.</p>
<p>We are using <a href="https://github.com/sebmarkbage/ecmascript-rest-spread">ES7 rest spread operator</a> here to keep our props generic. In other words that <code>&lt;div {...props}&gt;</code> sets props as element attributes. This gives an additional extension point with little effort. You could for instance attach custom event handlers there or set some standard HTML attributes (e.g. <code>&lt;Note title=&apos;Demo title&apos; value={note.task} /&gt;</code>). I extract <code>value</code> and <code>onEdit</code> out of <code>props</code> as I <strong>don&apos;t</strong> want to set these at <code>div</code>.</p>
<blockquote class="tip">It can be a good idea to name your callbacks using <code>on</code> prefix. This will allow you to distinguish them quickly from other props and keep your code a little tidier.</blockquote><p>In order to make our edit work we&apos;ll need to define a callback for <code>App</code> like this:</p>
<p><strong>app/components/App.jsx</strong></p>
<pre><code class="undefinedjavascript">...
<span class="hljs-keyword">import</span> findIndex <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../libs/find_index&apos;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  constructor(props) {
    <span class="hljs-keyword">super</span>(props);

    ...

    <span class="hljs-keyword">this</span>.addItem = <span class="hljs-keyword">this</span>.addItem.bind(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.itemEdited = <span class="hljs-keyword">this</span>.itemEdited.bind(<span class="hljs-keyword">this</span>);
  }
  render() {
    ...
    &lt;Notes items={notes} onEdit={<span class="hljs-keyword">this</span>.itemEdited} /&gt;
    ...
  }
  ...
  itemEdited(noteId, task) {
    <span class="hljs-keyword">let</span> notes = <span class="hljs-keyword">this</span>.state.notes;
    <span class="hljs-keyword">const</span> noteIndex = findIndex(notes, <span class="hljs-string">&apos;id&apos;</span>, noteId);

    <span class="hljs-keyword">if</span>(noteIndex &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">&apos;Failed to find note&apos;</span>, notes, noteId);
    }

    notes[noteIndex].task = task;

    <span class="hljs-keyword">this</span>.setState({notes});
  }
}
</code></pre>
<p>We are going to need a little helper to find array objects. If it finds something, it will return the index of the first match. This keeps our manipulations simple.</p>
<p><strong>app/libs/find_index.js</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findIndex</span>(<span class="hljs-params">arr, prop, value</span>) </span>{
  <span class="hljs-keyword">const</span> o = arr.filter(c =&gt; c[prop] === value)[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">const</span> ret = o &amp;&amp; arr.indexOf(o);

  <span class="hljs-keyword">return</span> ret &gt;= <span class="hljs-number">0</span> ? ret : -<span class="hljs-number">1</span>;
}
</code></pre>
<p>We also need to tweak <code>Notes</code> in order to bind the callback and pass the id of the edited <code>Note</code> to the parent:</p>
<p><strong>app/components/Notes.jsx</strong></p>
<pre><code class="undefinedjavascript">...

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Notes</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  constructor(props) {
    <span class="hljs-keyword">super</span>(props);

    <span class="hljs-keyword">this</span>.renderNote = <span class="hljs-keyword">this</span>.renderNote.bind(<span class="hljs-keyword">this</span>);
  }
  render() {
    <span class="hljs-keyword">const</span> notes = <span class="hljs-keyword">this</span>.props.items;

    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">ul</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&apos;notes&apos;</span>&gt;</span>{notes.map(this.renderNote)}<span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>;</span>
  }
  renderNote(note) {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&apos;note&apos;</span> <span class="hljs-attribute">key</span>=<span class="hljs-value">{`note${note.id}`}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">Note</span>
          <span class="hljs-attribute">value</span>=<span class="hljs-value">{note.task}</span>
          <span class="hljs-attribute">onEdit</span>=<span class="hljs-value">{this.props.onEdit.bind(null,</span> <span class="hljs-attribute">note.id</span>)} /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
    )</span>;
  }
}
</code></pre>
<p>After these changes you should be able to edit notes.</p>
<a class="header-anchor" href="#removing-notes" id="removing-notes"></a><h2>Removing Notes<a class="header-anchor-select" href="#removing-notes">#</a></h2>
<p>We are still missing one vital functionality. It would be nice to be able to remove notes. We can achieve this easily by extending edit.</p>
<p>In case we empty a task, it would make sense to remove it. You can give it a go yourself or follow the example below. It is just a matter of modifying state.</p>
<p><strong>app/components/App.jsx</strong></p>
<pre><code class="undefinedjavascript">...

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  ...
  itemEdited(noteId, task) {
    <span class="hljs-keyword">let</span> notes = <span class="hljs-keyword">this</span>.state.notes;
    <span class="hljs-keyword">const</span> noteIndex = findIndex(notes, <span class="hljs-string">&apos;id&apos;</span>, noteId);

    <span class="hljs-keyword">if</span>(noteIndex &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">&apos;Failed to find note&apos;</span>, notes, noteId);
    }

    <span class="hljs-keyword">if</span>(task) {
      notes[noteIndex].task = task;
    }
    <span class="hljs-keyword">else</span> {
      notes = notes.slice(<span class="hljs-number">0</span>, noteIndex).concat(notes.slice(noteIndex + <span class="hljs-number">1</span>));
    }

    <span class="hljs-keyword">this</span>.setState({notes});
  }
}
</code></pre>
<p>If you empty an input now, the new logic should trigger and get rid of the <code>Note</code> in question.</p>
<blockquote class="tip">We just introduced some interesting behavior to our system. As we track edit state on <code>Note</code> level, this means if you remove an item before the edited <code>Note</code>, the same old element remains edited. If we want to edit specific data, our data model should change to take this in count. Can you see how?</blockquote><a class="header-anchor" href="#understanding-react-components" id="understanding-react-components"></a><h2>Understanding React Components<a class="header-anchor-select" href="#understanding-react-components">#</a></h2>
<p>Besides understanding how props and state work it is important to understand the concept of component lifecycle. We already touched it briefly above but it&apos;s a good idea to understand it in more detail. You can achieve most tasks in React by applying these three concepts throughout your application.</p>
<p>To quote <a href="https://facebook.github.io/react/docs/component-specs.html">the official documentation</a> React provides the following <code>React.createClass</code> specific component specifications:</p>
<ul>
<li><code>displayName</code> - It is preferable to set <code>displayName</code> as that will improve debug information. For ES6 classes this is derived automatically based on the class name.</li>
<li><code>getInitialState()</code> - In class based approach the same can be achieved through <code>constructor</code>.</li>
<li><code>getDefaultProps()</code> - In classes you can set these in <code>constructor</code>.</li>
<li><code>propTypes</code> - As seen above you can use Flow to deal with prop types. In <code>React.createClass</code> you would build a complex looking declaration as seen in <a href="https://facebook.github.io/react/docs/reusable-components.html">the propType documentation</a>.</li>
<li><code>mixins</code> - <code>mixins</code> contains an array of mixins to apply to component.</li>
<li><code>statics</code> - <code>statics</code> contains static properties and method for a component. In ES6 you would assign them to the class like below:</li>
</ul>
<pre><code class="undefinedjavascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Note</span> </span>{
  render() {
    ...
  }
}
Note.willTransitionTo = () =&gt; {...};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Note;
</code></pre>
<p>Some libraries such as <code>react-dnd</code> rely on static methods to provide transition hooks that allow you to control what happens when a component is shown or hidden. By definition statics are available through class itself as you might guess from the code above.</p>
<p>Both component types support <code>render()</code>. As seen above this is the workhorse of React. It describes what the component should look like. In case you don&apos;t want to render anything return either <code>null</code> or <code>false</code>.</p>
<p>In addition React provides the following lifecycle hooks:</p>
<ul>
<li><code>componentWillMount()</code> gets triggered once before any rendering. One way to use it would be to load data asynchronously there and force rendering through <code>setState</code>.</li>
<li><code>componentDidMount()</code> gets triggered after initial rendering. You have access to DOM here. You could use this hook to wrap a jQuery plugin within a component for instance.</li>
<li><code>componentWillReceiveProps(object nextProps)</code> triggers when component receives new props. You could for instance modify your component state based on the received props.</li>
<li><code>shouldComponentUpdate(object nextProps, object nextState)</code> allows you to optimize rendering. If you check the props and state and see that there&apos;s no need to update, return <code>false</code>.</li>
<li><code>componentWillUpdate(object nextProps, object nextState)</code> gets triggered after <code>shouldComponentUpdate</code> and before <code>render()</code>. It is not possible to use <code>setState</code> here but you can set class properties for instance.</li>
<li><code>componentDidUpdate</code> is triggered after rendering. You can modify DOM here. This can be useful for adapting other code to work with React.</li>
<li><code>componentWillUnmount</code> is triggered just before a component is unmounted from DOM. This is the ideal place to perform cleanup (e.g. remove running timers, custom DOM elements and so on).</li>
</ul>
<a class="header-anchor" href="#react-component-conventions" id="react-component-conventions"></a><h2>React Component Conventions<a class="header-anchor-select" href="#react-component-conventions">#</a></h2>
<p>As seen in the above code I prefer to have <code>constructor</code> first, possible lifecycle hooks then, <code>render()</code> and finally methods used by <code>render()</code>. I like this top-down approach as it makes it straight-forward to follow code. Some prefer to put the methods used by <code>render()</code> before it. There are also various naming conventions. It is possible to use <code>_</code> prefix for event handlers for instance.</p>
<p>In the end you will have to find conventions you like and that work the best for you. I go more detail in this topic at the linting chapter as I introduce various code quality related tools. It is possible to enforce coding style to some extent for instance.</p>
<p>This can be useful in a team environment as it decreases the amount of friction when working on code written by others. Even on personal projects having some tools to check out things for you can be useful and lessen the amount and severity of mistakes.</p>
<a class="header-anchor" href="#conclusion" id="conclusion"></a><h2>Conclusion<a class="header-anchor-select" href="#conclusion">#</a></h2>
<p>You can get quite far just with vanilla React. Unfortunately our little application is already bursting at seams and we have a lot of features to implement. In the next chapter we will clean things up as we introduce Flux architecture and port our application to use it.</p>
</div><div class="social-links"><blockquote>If you enjoyed this chapter, consider subscribing to <a href="http://eepurl.com/bth1v5">the mailing list</a> or following <a href="https://twitter.com/survivejs">@survivejs</a> for occasional updates. There is also <a href="/atom.xml">RSS</a> available for old beards (no pun intended).</blockquote></div><div id="disqus_thread"></div><div class="prevnext"><div class="prevnext__prev"><div class="prevnext__bg" style="background-image:url(/images/mainframe.jpg);"></div><span class="prevnext__info">Previous chapter</span><a class="prevnext__link" href="/webpack_react/webpack_and_react">Webpack and React</a></div><div class="prevnext__next"><div class="prevnext__bg" style="background-image:url(/images/delorean.jpg);"></div><span class="prevnext__info">Next chapter</span><a class="prevnext__link" href="/webpack_react/react_and_flux">React and Flux</a></div></div><a class="next-page" href="/webpack_react/react_and_flux">React and Flux</a><a class="previous-page" href="/webpack_react/webpack_and_react">Webpack and React</a></div><div class="header-extra"><a href="https://www.flickr.com/photos/73635318@N00/2663422833">Angela (CC BY-NC-SA)</a></div><script type="text/javascript">var disqus_shortname = 'survivejs';(function() {var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script></div><noscript></noscript></main></div></body></html>