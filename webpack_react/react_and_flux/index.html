<html><head><title>SurviveJS - Webpack and React - React and Flux</title><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimal-ui"><meta name="description" content="
You can get quite far by keeping everything in components but eventually that will become painful. Flux application architecture was designed to help bring clarity to our React applications.

Flux will allow us to separate data and application state from our Views. This allows us to keep them cleanâ€¦"><meta name="keywords" content="webpack,react,javascript,programming,web development"><link rel="icon" type="image/png" href="../../assets/img/favicon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><link rel="stylesheet" href="../../assets/main.css"></head><body><div><div class="nav__wrapper"><input type="checkbox" class="nav__toggle" id="nav__toggle"><label class="nav__toggle-label" for="nav__toggle"></label><nav class="nav"><div class="nav__link"><a href="/">Home</a></div><div class="nav__link"><a href="/blog">Read the blog</a></div><div class="nav__link"><a href="https://leanpub.com/survivejs_webpack">Buy the ebook</a></div><div class="nav__link"><a href=""></a></div><div class="nav__link"><a href="https://twitter.com/survivejs">@survivejs</a></div></nav></div><div class="right ribbon github-fork-ribbon-wrapper"><div class="github-fork-ribbon" style="background-color:black;"><a href="https://github.com/survivejs/webpack_react/issues/new?title=React and Flux - " target="_blank">Submit feedback</a></div></div><main role="main"><div class="chapter__wrapper"><div class="header-image" style="background-image:url(/images/delorean.jpg);"></div><h1 class="post__heading">React and Flux</h1><div class="toc-nav__wrapper"><h4 class="toc-nav--header">Table of Contents</h4><div class="toc-nav"><a href="/webpack_react/introduction" class="toc-nav__link chapter">Introduction</a><a href="/webpack_react/webpack" class="toc-nav__link part">Setting Up Webpack</a><a href="/webpack_react/webpack_compared" class="toc-nav__link chapter">Webpack Compared</a><a href="/webpack_react/developing_with_webpack" class="toc-nav__link chapter">Developing with webpack</a><a href="/webpack_react/webpack_and_react" class="toc-nav__link chapter">Webpack and React</a><a href="/webpack_react/react" class="toc-nav__link part">Developing Kanban Application</a><a href="/webpack_react/implementing_notes" class="toc-nav__link chapter">Implementing a Basic Note Application</a><span class="toc-nav__link toc-nav__link--current chapter">React and Flux</span><a href="/webpack_react/from_notes_to_kanban" class="toc-nav__link chapter">From Notes to Kanban</a><a href="/webpack_react/implementing_dnd" class="toc-nav__link chapter">Implementing Drag and Drop</a><a href="/webpack_react/building_kanban" class="toc-nav__link chapter">Building Kanban</a><a href="/webpack_react/advanced" class="toc-nav__link part">Advanced Techniques</a><a href="/webpack_react/linting_in_webpack" class="toc-nav__link chapter">Linting in webpack</a><a href="/webpack_react/deploying_applications" class="toc-nav__link chapter">Deploying Applications</a><a href="/webpack_react/authoring_libraries" class="toc-nav__link chapter">Authoring Libraries</a><a href="/webpack_react/styling_react" class="toc-nav__link chapter">Styling React</a><a href="/webpack_react/troubleshooting" class="toc-nav__link chapter">Troubleshooting</a></div></div><div class="chapter"><div class="post__content"><div class="post__meta"><div class="post__start_source"><a href="https://github.com/survivejs/webpack_react/tree/master/project_source/04_implementing_notes/kanban_app" target="_blank">Start source code</a></div><div class="post__end_source"><a href="https://github.com/survivejs/webpack_react/tree/master/project_source/05_react_and_flux/kanban_app" target="_blank">Finished source code</a></div><div class="post__demo"><a href="/demos/05_react_and_flux" target="_blank">Demo</a></div></div><div><p>You can get quite far by keeping everything in components but eventually that will become painful. <a href="https://facebook.github.io/flux/docs/overview.html">Flux application architecture</a> was designed to help bring clarity to our React applications.</p>
<p>Flux will allow us to separate data and application state from our Views. This allows us to keep them clean and keep the application maintainable. Flux was designed large teams in mind. As a result you might find it quite verbose. This comes with great advantages, though, as it can be straightforward to work with.</p>
<a class="header-anchor" href="#introduction-to-flux" id="introduction-to-flux"></a><h2>Introduction to Flux<a class="header-anchor-select" href="#introduction-to-flux">#</a></h2>
<p><img src="/images/flux.png" alt="Flux dataflow"></p>
<p>So far we&apos;ve been dealing only with Views. Flux architecture introduces a couple of new concepts to the mix. These are Actions, Dispatcher and Stores. Flux implements unidirectional flow in contrast to popular frameworks such as Angular or Ember. Even though two-directional bindings can be convenient and some things are easier to implement using them, the Flux way of doing things comes with its benefits.</p>
<a class="header-anchor" href="#dataflow-in-flux" id="dataflow-in-flux"></a><h3>Dataflow in Flux<a class="header-anchor-select" href="#dataflow-in-flux">#</a></h3>
<p>Using Flux we&apos;ll model data related aspects at Stores. Views may still retain some state but in practice a lot of it will go to Stores. Besides application data they can maintain application state as well (i.e. is something loading). You then consume this data at your View components. Views can trigger Actions that cause Store to change somehow.</p>
<p>You could for instance have an action for creating a new Note. Pressing a button at your View could trigger it. Based on this Dispatcher will trigger relevant Stores. They in turn will update their state somehow (i.e. create a Note) and pass their state forward. As a result Views will know to render themselves with the new data.</p>
<a class="header-anchor" href="#advantages-of-flux" id="advantages-of-flux"></a><h3>Advantages of Flux<a class="header-anchor-select" href="#advantages-of-flux">#</a></h3>
<p>Even though this sounds a little complicated, the arrangement gives our application flexibility. We can for instance implement API communication, caching and i18n outside of our Views. This way they stay clean of logic while keeping the application easier to understand.</p>
<p>Implementing Flux architecture in your application will actually increase the amount of code somewhat. It is important to understand minimizing the amount of code written isn&apos;t the goal of Flux. It has been designed to allow productivity across larger teams. You could say explicit is better than implicit.</p>
<a class="header-anchor" href="#relay-" id="relay-"></a><h3>Relay?<a class="header-anchor-select" href="#relay-">#</a></h3>
<p>Facebook&apos;s <a href="https://facebook.github.io/react/blog/2015/02/20/introducing-relay-and-graphql.html">Relay</a> can be considered an improvement over Flux. It improves especially on the data fetching department and allows you to push data requirements to the View level. As it is still a completely new technology we won&apos;t be discussing it yet in detail.</p>
<a class="header-anchor" href="#which-flux-implementation-to-use-" id="which-flux-implementation-to-use-"></a><h3>Which Flux Implementation to Use?<a class="header-anchor-select" href="#which-flux-implementation-to-use-">#</a></h3>
<p>The library situation keeps on changing constantly as there is no single right way to interpret the architecture. You will find implementations fitting for different tastes. <a href="https://github.com/voronianski/flux-comparison">voronianski/flux-comparison</a> provides a nice comparison between some of the more popular ones.</p>
<p>When choosing a library it comes down to your own personal preferences. You will have to consider factors such as API, features, documentation and support. Starting with one of the more popular alternatives can be a good idea. As you begin to understand the architecture you are able to make choices that serve you better.</p>
<a class="header-anchor" href="#porting-to-alt" id="porting-to-alt"></a><h2>Porting to Alt<a class="header-anchor-select" href="#porting-to-alt">#</a></h2>
<p><img src="/images/alt.png" alt="Alt"></p>
<p>In this chapter we&apos;ll be using one of the current top dogs, a library known as <a href="http://alt.js.org/">Alt</a>. It is a flexible, full-featured implementation that has been designed isomorphic rendering in mind.</p>
<p>In Alt you&apos;ll deal in terms of Actions and Stores. Dispatcher is hidden but you will still have access to it if needed. There are special features to allow you to save and restore application state. This is handy for implementing persistency and isomorphic rendering.</p>
<a class="header-anchor" href="#setting-up-alt-instance" id="setting-up-alt-instance"></a><h3>Setting Up Alt Instance<a class="header-anchor-select" href="#setting-up-alt-instance">#</a></h3>
<p>Everything in Alt begins from Alt instance. It keeps track of Actions and Stores and keeps communication going on. It is a singleton by default but it&apos;s possible to create Alt instances as needed. Alt doesn&apos;t force you to any particular design. To get started hit</p>
<blockquote>
<p>npm i alt --save</p>
</blockquote>
<p>to add Alt to our project.</p>
<p>To keep things simple we&apos;ll be treating Alt as a singleton. This is possible to achieve by pushing it to a module of its own and then referring to that from everywhere. Set it up as follows:</p>
<p><strong>app/libs/alt.js</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> Alt <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;alt&apos;</span>;
<span class="hljs-comment">//import chromeDebug from &apos;alt/utils/chromeDebug&apos;;</span>

<span class="hljs-keyword">const</span> alt = <span class="hljs-keyword">new</span> Alt();
<span class="hljs-comment">//chromeDebug(alt);</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> alt;
</code></pre>
<blockquote class="tip">There is a Chrome plugin known as <a href="https://github.com/goatslacker/alt-devtool">alt-devtool</a>. After installed you can connect Alt with it by uncommenting the lines below. You can use it to debug the state of your stores, search and travel in time.</blockquote><a class="header-anchor" href="#defining-crud-api-for-notes" id="defining-crud-api-for-notes"></a><h3>Defining CRUD API for Notes<a class="header-anchor-select" href="#defining-crud-api-for-notes">#</a></h3>
<p>Next we&apos;ll need to define a basic API for operating over Note data. To keep this simple, let&apos;s CRUD (CReate, Update, Delete) it. These will be the basic Actions we use to operate our Notes. Alt provides a shorthand known as <code>generateActions</code>. We can use it like this:</p>
<p><strong>app/actions/NoteActions.js</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> alt <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../libs/alt&apos;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> alt.generateActions(<span class="hljs-string">&apos;create&apos;</span>, <span class="hljs-string">&apos;update&apos;</span>, <span class="hljs-string">&apos;delete&apos;</span>);
</code></pre>
<p>Alt provides an alternative, verbose syntax for defining Actions. It is handy when you begin to communicating with an external API. Each API query would go here and you would trigger other Actions based on the result. You could then decide what to do with the results.</p>
<blockquote class="tip">You can even track request state by setting up a custom Store just for that. In that case you would trigger Actions that alter the state of that Store. You could have a component that logs the result or shows it at the user interface based on that.</blockquote><p>If we wanted to model Actions using the verbose syntax it would look like this:</p>
<pre><code class="undefinedjavascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoteActions</span> </span>{
  create({id, task}) {
    <span class="hljs-keyword">this</span>.dispatch({id, task});
  }
  update({id, task}) {
    <span class="hljs-keyword">this</span>.dispatch({id, task});
  }
  <span class="hljs-keyword">delete</span>(id) {
    <span class="hljs-keyword">this</span>.dispatch(id);
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> alt.createActions(NoteActions);
</code></pre>
<p>Having a nice set of Actions is a starting point. As you might remember we still need Stores. And we need to complete the cycle by connecting all of this to a View.</p>
<a class="header-anchor" href="#defining-store-for-notes" id="defining-store-for-notes"></a><h3>Defining Store for Notes<a class="header-anchor-select" href="#defining-store-for-notes">#</a></h3>
<p>The main purpose of a Store is to deal with data and application state related concerns. In this case it will maintain the state of Notes and alter it based on operations we apply on it. We will connect it with the actions we defined above using <code>bindActions</code> shortcut.</p>
<p><code>bindActions</code> maps each Action to a method by name. We trigger appropriate logic at each method based on that. Finally we connect the Store with Alt using <code>alt.createStore</code>. This will treat our Stores as singleton so it&apos;s the same idea as for Alt instance. It is possible to create individual Store instances but singleton works for our case.</p>
<p>The implementation below describes logic that will be sufficient for this application. A lot of it might be familiar from the previous chapter. Here we are lifting that logic out of View level.</p>
<p>To keep the implementation clean we are using <code>this.setState</code>, a feature of Alt that allows us to signify that we are going to alter Store state and that it should signal the change to possible listeners.</p>
<p><strong>app/stores/NoteStore.js</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> alt <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../libs/alt&apos;</span>;
<span class="hljs-keyword">import</span> NoteActions <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../actions/NoteActions&apos;</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoteStore</span> </span>{
  constructor() {
    <span class="hljs-keyword">this</span>.bindActions(NoteActions);

    <span class="hljs-keyword">this</span>.notes = [];
  }
  create(note) {
    <span class="hljs-keyword">const</span> notes = <span class="hljs-keyword">this</span>.notes;

    <span class="hljs-keyword">this</span>.setState({
      notes: notes.concat(note)
    });
  }
  update({id, task}) {
    <span class="hljs-keyword">const</span> notes = <span class="hljs-keyword">this</span>.notes;
    <span class="hljs-keyword">const</span> targetId = notes.findIndex((o) =&gt; note.id === id);

    notes[targetId].task = task;

    <span class="hljs-keyword">this</span>.setState({notes});
  }
  <span class="hljs-keyword">delete</span>(id) {
    <span class="hljs-keyword">const</span> notes = <span class="hljs-keyword">this</span>.notes;
    <span class="hljs-keyword">const</span> targetId = notes.findIndex((note) =&gt; note.id === id);

    <span class="hljs-keyword">this</span>.setState({
      notes: notes.slice(<span class="hljs-number">0</span>, targetId).concat(notes.slice(targetId + <span class="hljs-number">1</span>))
    });
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> alt.createStore(NoteStore, <span class="hljs-string">&apos;NoteStore&apos;</span>);
</code></pre>
<blockquote class="tip">It would be possible to operate directly on data. E.g. a oneliner such as <code>this.notes.splice(targetId, 1)</code> would work for <code>delete</code>. Even though this works it is recommended that you use <code>setState</code> with Alt to keep things clean and easy to understand.</blockquote><p>Note that assigning an id (<code>NoteStore</code> in this case) to a store isn&apos;t absolutely required. It is a good practice, however, as it protects the code against minification and possible id collisions. These ids become important when we persist the data.</p>
<p>We have almost integrated Flux to our application. Now we have a set of Actions that provide an API for manipulating <code>Notes</code> data. We also have a Store for actual data manipulation. We are missing one final bit - integration with our View. It will have to listen to the Store and be able to trigger Actions.</p>
<blockquote class="tip">The current implementation is naive in that it doesn&apos;t validate parameters in any way. It would be a very good idea to validate the object shape to avoid incidents during development. <a href="http://flowtype.org/">Flow</a> based gradual typing provides one way to do this. Alternatively you could write nice tests. That&apos;s a good idea regardless.</blockquote><a class="header-anchor" href="#gluing-it-all-together" id="gluing-it-all-together"></a><h3>Gluing It All Together<a class="header-anchor-select" href="#gluing-it-all-together">#</a></h3>
<p>Gluing this all together is a little complicated as there are multiple concerns to take care of. Dealing with Actions is going to be easy. For instance to create a Note, we would need to trigger <code>NoteActions.create({id: uuid.v4(), task: &apos;New task&apos;})</code>. This would cause the associated Store to change according to the logic. Because Store changes so do all the components listening to it.</p>
<p>There are multiple ways to connect the Store to our View. Our <code>NoteStore</code> provides two methods in particular that are going to be useful. These are <code>NoteStore.listen</code> and <code>NoteStore.unlisten</code>. They will allow us to keep track of the state and synchronize it with our components.</p>
<p>As you might remember from the earlier chapters React provides a set of lifecycle hooks. We can connect <code>NoteStore</code> with our View using <code>listen/unlisten</code> at <code>componentDidMount</code> and <code>componentWillUnmount</code>. Doing it this way makes sure we don&apos;t have weird references hanging around if/when components get created and removed.</p>
<p>Performing all of the needed changes piecewise wouldn&apos;t be nice I have included whole <code>App</code> View below. Take note how we use <code>NoteActions</code> and <code>NoteStore</code> in particular. As we alter <code>NoteStore</code>, this leads to a cascade that causes our <code>App</code> state update through <code>setState</code>. This in turn will trigger component <code>render</code>.</p>
<p><strong>app/components/App.jsx</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> uuid <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;node-uuid&apos;</span>;
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;react&apos;</span>;
<span class="hljs-keyword">import</span> Notes <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./Notes&apos;</span>;
<span class="hljs-keyword">import</span> NoteActions <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../actions/NoteActions&apos;</span>;
<span class="hljs-keyword">import</span> NoteStore <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../stores/NoteStore&apos;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  constructor(props) {
    <span class="hljs-keyword">super</span>(props);

    <span class="hljs-keyword">this</span>.storeChanged = <span class="hljs-keyword">this</span>.storeChanged.bind(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.state = NoteStore.getState();
  }
  componentDidMount() {
    NoteStore.listen(<span class="hljs-keyword">this</span>.storeChanged);
  }
  componentWillUnmount() {
    NoteStore.unlisten(<span class="hljs-keyword">this</span>.storeChanged);
  }
  storeChanged(state) {
    <span class="hljs-keyword">this</span>.setState(state);
  }
  render() {
    <span class="hljs-keyword">const</span> notes = <span class="hljs-keyword">this</span>.state.notes;

    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">button</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{this.addItem}</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">Notes</span> <span class="hljs-attribute">items</span>=<span class="hljs-value">{notes}</span> <span class="hljs-attribute">onEdit</span>=<span class="hljs-value">{this.itemEdited}</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    )</span>;
  }
  addItem() {
    NoteActions.create({id: uuid.v4(), task: <span class="hljs-string">&apos;New task&apos;</span>});
  }
  itemEdited(id, task) {
    <span class="hljs-keyword">if</span>(task) {
      NoteActions.update({id, task});
    }
    <span class="hljs-keyword">else</span> {
      NoteActions.delete(id);
    }
  }
}
</code></pre>
<p>As you can see, we pushed the logic out of <code>App</code>. We actually have more code now than before but that&apos;s okay. <code>App</code> is a little neater now and it&apos;s going to be easier to develop as we&apos;ll see soon. Most importantly we have managed to implement Flux architecture for our application. Things can only get better.</p>
<a class="header-anchor" href="#dispatching-in-alt" id="dispatching-in-alt"></a><h3>Dispatching in Alt<a class="header-anchor-select" href="#dispatching-in-alt">#</a></h3>
<p>Even though you can get far without ever using Flux dispatcher, it can be useful to know something about it. Alt provides two ways to use it. If you want to log everything that goes through your <code>alt</code> instance, you can use a snippet such as <code>alt.dispatcher.register(console.log.bind(console))</code>.</p>
<p>You can use the same mechanism on Store level. In that case you would trigger <code>this.dispatcher.register(...)</code> at constructor. These mechanisms allow you to implement effective logging to your system.</p>
<a class="header-anchor" href="#what-s-the-point-" id="what-s-the-point-"></a><h3>What&apos;s the Point?<a class="header-anchor-select" href="#what-s-the-point-">#</a></h3>
<p>Even though integrating Alt took a lot of effort, it was not all in vain. Consider the following questions:</p>
<ol>
<li>Let&apos;s say we wanted to persist the Notes within <code>localStorage</code>, where would you implement that? It would be natural to plug that into our <code>NoteStore</code>. Alternatively we could do something more generic as we&apos;ll be doing next.</li>
<li>What if we had multiple components relying on the data? We would just consume <code>NoteStore</code> and display it however we want.</li>
<li>What if we had multiple, separate Note lists for different type of tasks? We could set up another Store for tracking these lists. That Store could refer to actual Notes by id. We&apos;ll do something like this in the next chapter as we generalize the approach.</li>
</ol>
<p>This is what makes Flux a strong architecture when used with React. It isn&apos;t hard to find answers to questions like these. Even though there is more code, it is easier to reason about. Given we are dealing with unidirectional flow we have something that is simple to debug and test.</p>
<a class="header-anchor" href="#implementing-persistency-over-localstorage-" id="implementing-persistency-over-localstorage-"></a><h2>Implementing Persistency over <code>localStorage</code><a class="header-anchor-select" href="#implementing-persistency-over-localstorage-">#</a></h2>
<p>Given it&apos;s not nice to lose your Notes after a refresh, we can tweak our implementation of <code>NoteStore</code> to persist the data on change. One way to achieve this is to use <a href="https://developer.mozilla.org/en/docs/Web/API/Window/localStorage">localStorage</a>. It is a well supported feature that allows you to persist data at browser.</p>
<a class="header-anchor" href="#understanding-localstorage-" id="understanding-localstorage-"></a><h3>Understanding <code>localStorage</code><a class="header-anchor-select" href="#understanding-localstorage-">#</a></h3>
<p>It has a sibling known as <code>sessionStorage</code>. <code>sessionStorage</code> loses its data when browser is closed, <code>localStorage</code> doesn&apos;t.</p>
<p>They both share <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API">the same API</a> as discussed below:</p>
<ul>
<li><code>storage.getItem(k)</code> - Returns stored string</li>
<li><code>storage.removeItem(k)</code> - Removes data matching to key</li>
<li><code>storage.setItem(k, v)</code> - Stores given value using given key</li>
<li><code>storage.clear()</code> - Empties storage contents</li>
</ul>
<p>Note that it is convenient to operate on the API using your browser developer tools. For instance in Chrome you can see the state of the storages through the <em>Resources</em> tab. <em>Console</em> tab allows you to perform direct operations on the data. You can even use <code>storage.key</code> and <code>storage.key = &apos;value&apos;</code> shorthands for quick modifications.</p>
<p><code>localStorage</code> and <code>sessionStorage</code> can use up to 10 MB of data combined. Even though they are well supported there are certain corner cases that may yield interesting failures. These include running out of memory at Internet Explorer (fails silently) and failing altogether at Safari private mode. It is possible to work around these glitches, though.</p>
<blockquote class="tip">You can support Safari private mode by trying to write into <code>localStorage</code> first. If that fails, you can use in-memory store instead or just let the user know about the situation. See <a href="https://stackoverflow.com/questions/14555347/html5-localstorage-error-with-safari-quota-exceeded-err-dom-exception-22-an">Stack Overflow</a> for details.</blockquote><a class="header-anchor" href="#implementing-a-wrapper-for-localstorage-" id="implementing-a-wrapper-for-localstorage-"></a><h3>Implementing a Wrapper for <code>localStorage</code><a class="header-anchor-select" href="#implementing-a-wrapper-for-localstorage-">#</a></h3>
<p>To keep things simple and manageable we can implement a little wrapper for <code>storage</code>. It will wrap all of these complexities. Given the API operates over strings and it is convenient to store objects we&apos;ll deal with serialization here using <code>JSON.parse</code> and <code>JSON.stringify</code>.</p>
<p>In a more serious case it could be a good idea to use a library such as <a href="https://github.com/mozilla/localForage">localForage</a> to hide all the complexity for you. You could even integrate it behind this little interface of ours. All we need are just <code>storage.get(k)</code> and <code>storage.set(k, v)</code> as seen in the implementation below:</p>
<p><strong>app/libs/storage.js</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">k</span>) </span>{
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(localStorage.getItem(k));
    }
    <span class="hljs-keyword">catch</span>(e) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
  },
  set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">k, v</span>) </span>{
    localStorage.setItem(k, <span class="hljs-built_in">JSON</span>.stringify(v));
  }
};
</code></pre>
<a class="header-anchor" href="#persisting-application-using-finalstore-" id="persisting-application-using-finalstore-"></a><h3>Persisting Application Using <code>FinalStore</code><a class="header-anchor-select" href="#persisting-application-using-finalstore-">#</a></h3>
<p>Besides this little utility we&apos;ll need to adapt our application to use it. Alt provides handy functionality just for this purpose. We can persist the entire state of our application using <code>FinalStore</code>, bootstrapping and snapshotting. <code>FinalStore</code> is store that listens to all existing stores. Every time some store changes, <code>FinalStore</code> will know about it. This makes it ideal for persistency.</p>
<p>We can take a snapshot of the entire app state and push it to <code>localStorage</code> every time <code>FinalStore</code> changes. That solves one part of the problem. Bootstrapping solves the remaining part. <code>alt.bootstrap</code> allows us to set state of the all stores. In our case we&apos;ll fetch the data from <code>localStorage</code> and invoke it to populate our stores. This is handy for other cases as well. The data can come from elsewhere through a WebSocket for instance.</p>
<blockquote class="tip">An alternative way would be to take a snapshot only when the window gets closed. There&apos;s a Window level <code>beforeunload</code> hook that could be used. The problem with this approach is that it is brittle. What if something unexpected happens and the hook doesn&apos;t get triggered for some reason? You&apos;ll lose data.</blockquote><p>In order to integrate this idea to our application we will need to implement a little module to manage it, take the possible initial data in count at <code>NoteStore</code> and finally trigger the new logic at initialization phase.</p>
<p><em>app/libs/persist.js</em>  does the hard part. It will set up a <code>FinalStore</code>, deal with bootstrapping (restore data) and listening the store for snapshotting (save data). I have included an escape hatch in form of <code>debug</code> flag. If it is set, the data won&apos;t get saved to <code>localStorage</code>. The reasoning is that now you can set the flag (<code>localStorage.setItem(&apos;debug&apos;, &apos;true&apos;)</code>), hit <code>localStorage.clear()</code> and refresh the browser to get a clean slate. The implementation below illustrates these ideas:</p>
<p><strong>app/libs/persist.js</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> makeFinalStore <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;alt/utils/makeFinalStore&apos;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">alt, storage, storeName</span>) </span>{
  <span class="hljs-keyword">const</span> finalStore = makeFinalStore(alt);

  alt.bootstrap(storage.get(storeName));

  finalStore.listen(() =&gt; {
    <span class="hljs-keyword">if</span>(!storage.get(<span class="hljs-string">&apos;debug&apos;</span>)) {
      storage.set(storeName, alt.takeSnapshot());
    }
  });
}
</code></pre>
<p>In order to make our <code>NoteStore</code> aware of possibly existing data, we&apos;ll need to tweak our constructor to take it in count. The data might not exist already, though, so we&apos;ll still need a default.</p>
<p><strong>app/stores/NoteStore.js</strong></p>
<pre><code class="undefinedjavascript">...

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoteStore</span> </span>{
  constructor() {
    <span class="hljs-keyword">this</span>.bindActions(NoteActions);

    <span class="hljs-keyword">this</span>.notes = <span class="hljs-keyword">this</span>.notes || [];
  }
  ...
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> alt.createStore(NoteStore, <span class="hljs-string">&apos;NoteStore&apos;</span>);
</code></pre>
<p>Finally we need to trigger persistency logic at initialization. We will need to pass relevant data to it (Alt instance, storage, storage name) and off we go.</p>
<p><strong>app/main.jsx</strong></p>
<pre><code class="undefinedjavascript">...
<span class="hljs-keyword">import</span> alt <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./libs/alt&apos;</span>;
<span class="hljs-keyword">import</span> storage <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./libs/storage&apos;</span>;
<span class="hljs-keyword">import</span> persist <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./libs/persist&apos;</span>;

main();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>{
  persist(alt, storage, <span class="hljs-string">&apos;app&apos;</span>);

  ...
}
</code></pre>
<p>If you try refreshing the browser now, the application should retain its state. More interestingly the solution should scale with minimal effort if we add more stores to the system. Integrating a real backend wouldn&apos;t be a problem. There are hooks in place for that now.</p>
<p>You could for instance pass the initial payload as a part of your HTML (isomorphic rendering), load it up and then persist the data to the backend. You have a great deal of control over how to do this and you can use <code>localStorage</code> as a backup if you want.</p>
<blockquote class="warning">Our <code>persist</code> implementation isn&apos;t without its flaws. It is easy to end up in a situation where <code>localStorage</code> contains invalid data due to changes made to the data model. This brings you to the world of database schemas and migrations. There are no easy solutions. Regardless this is something to keep in mind when developing something more sophisticated. The lesson here is that the more you inject state to your application, the more complicated it gets.</blockquote><a class="header-anchor" href="#extracting-connection-decorator" id="extracting-connection-decorator"></a><h2>Extracting Connection Decorator<a class="header-anchor-select" href="#extracting-connection-decorator">#</a></h2>
<p>Even though the application is starting to look a little better now, there&apos;s still work to be done. For instance <code>App</code> contains plenty of store connection related logic. This isn&apos;t nice. We should extract that so it&apos;s easier to manage.</p>
<a class="header-anchor" href="#decorators-what-are-they-" id="decorators-what-are-they-"></a><h3>Decorators - What Are They?<a class="header-anchor-select" href="#decorators-what-are-they-">#</a></h3>
<p>If you have used languages such as Java or Python before you might be familiar with the concept of decorators. They are syntactical sugar that allow us to wrap classes and functions. In short they provide us a way to annotate and push logic elsewhere while keeping our components simple to read.</p>
<p>There is a <a href="https://github.com/wycats/javascript-decorators">Stage 1 decorator proposal</a> for JavaScript. We&apos;ll be using that. By definition a decorator is simply a function that returns a function. For instance invocation of our <code>connect</code> decorator could look like <code>connect(NoteStore)(App)</code> without using the decorator syntax (<code>@connect(NoteStore)</code>).</p>
<a class="header-anchor" href="#implementing-connect-" id="implementing-connect-"></a><h3>Implementing <code>@connect</code><a class="header-anchor-select" href="#implementing-connect-">#</a></h3>
<p><code>@connect</code> will wrap our component in another component that in turn will deal with the connection logic (<code>listen/unlisten/setState</code>). It will maintain the store state internally and then pass it to the child component we are wrapping. During this process it will pass the state through props. The implementation below illustrates the idea:</p>
<p><strong>app/decorators/connect.js</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;react&apos;</span>;

<span class="hljs-keyword">const</span> connect = (Component, store) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Connect</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    constructor(props) {
      <span class="hljs-keyword">super</span>(props);

      <span class="hljs-keyword">this</span>.storeChanged = <span class="hljs-keyword">this</span>.storeChanged.bind(<span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">this</span>.state = store.getState();

      store.listen(<span class="hljs-keyword">this</span>.storeChanged);
    }
    componentWillUnmount() {
      store.unlisten(<span class="hljs-keyword">this</span>.storeChanged);
    }
    storeChanged() {
      <span class="hljs-keyword">this</span>.setState(store.getState());
    }
    render() {
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Component</span> {<span class="hljs-attribute">...this.props</span>} {<span class="hljs-attribute">...this.state</span>} /&gt;</span>;</span>
    }
  };
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (store) =&gt; {
  <span class="hljs-keyword">return</span> (target) =&gt; connect(target, store);
};
</code></pre>
<blockquote class="tip"><code>...</code> is known as <a href="https://github.com/sebmarkbage/ecmascript-rest-spread">ES7 rest spread operator</a>. I use it here to extract the props and state and pass them further as props.</blockquote><p>You can connect it with <code>App</code> like this:</p>
<p><strong>app/components/App.jsx</strong></p>
<pre><code class="undefinedjavascript">...
<span class="hljs-keyword">import</span> connect <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../decorators/connect&apos;</span>;

...

@connect(NoteStore)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">const</span> notes = <span class="hljs-keyword">this</span>.props.notes;

    ...
  }
  ...
}
</code></pre>
<p>Note how much code this simple decorator removes from our <code>App</code>. If we wanted to add more stores to the system and connect them to components, it would be trivial now. Even better we could connect multiple stores to a single component easily.</p>
<a class="header-anchor" href="#decorator-ideas" id="decorator-ideas"></a><h3>Decorator Ideas<a class="header-anchor-select" href="#decorator-ideas">#</a></h3>
<p>We can build new decorators for various functionalities, such as undo, in this manner. Every time we feel like logic is starting to creep into our components, it can be a good idea to stop for a while and see if a decorator could be extracted.</p>
<p>Decorators provide a nice way to slice logic out of our components while increasing maintainability of our projects. Even better well designed decorators can be usable across projects.</p>
<a class="header-anchor" href="#alt-s-connecttostores-" id="alt-s-connecttostores-"></a><h3>Alt&apos;s <code>@connectToStores</code><a class="header-anchor-select" href="#alt-s-connecttostores-">#</a></h3>
<p>Alt provides a similar decorator known as <code>@connectToStores</code>. It relies on static methods. This a ES6 feature and you might be familiar with it from other languages. Rather than normal methods that are bound to a specific instance these are bound on class level. This means you can call them through the class itself (i.e. <code>App.getStores()</code>). The example below shows how we might integrate <code>@connectToStores</code> into our application.</p>
<pre><code class="undefinedjavascript">...
<span class="hljs-keyword">import</span> connectToStores <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;alt/utils/connectToStores&apos;</span>;

@connectToStores
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  static getStores(props) {
    <span class="hljs-keyword">return</span> [NoteStore];
  }
  static getPropsFromStores(props) {
    <span class="hljs-keyword">return</span> NoteStore.getState();
  }
  ...
}
</code></pre>
<p>This more verbose approach is roughly equivalent to our implementation. It actually does more as it allows you to connect to multiple stores at once. It also provides more control over the way you can shape store state to props.</p>
<p>In order to get familiar with more approaches we&apos;ll be using <code>AltContainer</code> in this project instead. That said using the decorator is completely acceptable as well and it comes down to your personal preferences.</p>
<a class="header-anchor" href="#using-altcontainer-instead-of-a-decorator" id="using-altcontainer-instead-of-a-decorator"></a><h2>Using <code>AltContainer</code> Instead of a Decorator<a class="header-anchor-select" href="#using-altcontainer-instead-of-a-decorator">#</a></h2>
<p><a href="http://alt.js.org/docs/components/altContainer/">AltContainer</a> wrapper that does the same thing and a bit more. It provides a greater degree of customizability than our own solution and it&apos;s officially supported by Alt protecting us from possible API changes.</p>
<p>You will see the wrapper pattern later again in this book and you will learn to implement it yourself. In this case the pattern it will allow us to set up arbitrary connections to multiple stores while having control over how to inject them to the contained components. Particularly this fact will become important as we grow the application.</p>
<p>The implementation below illustrates how to bind it all together. We&apos;ll drop <code>@connect</code> from the project altogether and expand <code>render()</code> to use <code>AltContainer</code>. After these changes we are good to go.</p>
<p><strong>app/components/App.jsx</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> uuid <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;node-uuid&apos;</span>;
<span class="hljs-keyword">import</span> AltContainer <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;alt/AltContainer&apos;</span>;
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;react&apos;</span>;
<span class="hljs-keyword">import</span> Notes <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./Notes&apos;</span>;
<span class="hljs-keyword">import</span> NoteActions <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../actions/NoteActions&apos;</span>;
<span class="hljs-keyword">import</span> NoteStore <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../stores/NoteStore&apos;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">button</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{this.addItem}</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">AltContainer</span>
          <span class="hljs-attribute">stores</span>=<span class="hljs-value">{[NoteStore]}</span>
          <span class="hljs-attribute">inject</span>=<span class="hljs-value">{</span> {
            <span class="hljs-attribute">items:</span> () =&gt;</span> NoteStore.getState().notes
          } }
        &gt;
          <span class="hljs-tag">&lt;<span class="hljs-title">Notes</span> <span class="hljs-attribute">onEdit</span>=<span class="hljs-value">{this.itemEdited}</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">AltContainer</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    )</span>;
  }
  ...
}
</code></pre>
<p>Integrating <code>AltContainer</code> actually grew our component a little bit. It also tied this component to Alt. If you wanted something forward-looking, you could consider pushing it into component of your own. That facade would hide Alt effectively and allow you to replace it with something else later on.</p>
<a class="header-anchor" href="#conclusion" id="conclusion"></a><h2>Conclusion<a class="header-anchor-select" href="#conclusion">#</a></h2>
<p>In this chapter you saw how to port our simple application to use Flux architecture. In the process we learned about basic concepts of Flux. We also learned to extract logic into decorators. Now we are ready to start adding more functionality to our application with less frustration.</p>
</div><div class="social-links"><blockquote class="tip">If you enjoyed this chapter consider subscribing to <a href="http://eepurl.com/bth1v5">the mailing list</a> or following <a href="https://twitter.com/survivejs">@survivejs</a> for occasional updates. There is also <a href="/atom.xml">RSS</a> available for old beards (no pun intended).</blockquote></div><div id="disqus_thread"></div><div class="prevnext"><div class="prevnext__prev"><div class="prevnext__bg" style="background-image:url(/images/notes.jpg);"></div><span class="prevnext__info">Previous chapter</span><a class="prevnext__link" href="/webpack_react/implementing_notes">Implementing a Basic Note Application</a></div><div class="prevnext__next"><div class="prevnext__bg" style="background-image:url(/images/kanban_photo.jpg);"></div><span class="prevnext__info">Next chapter</span><a class="prevnext__link" href="/webpack_react/from_notes_to_kanban">From Notes to Kanban</a></div></div><a class="next-page" href="/webpack_react/from_notes_to_kanban">From Notes to Kanban</a><a class="previous-page" href="/webpack_react/implementing_notes">Implementing a Basic Note Application</a></div><div class="header-extra"><a href="https://www.flickr.com/photos/126433814@N04/16298563416">jeremyg3030 (CC BY)</a></div></div><script type="text/javascript">var disqus_shortname = 'survivejs';(function() {var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script></div><noscript></noscript></main></div></body></html>